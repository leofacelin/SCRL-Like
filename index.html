<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Spark Canvas - V104 (V102-RubberBand + 混合导出策略)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300..900&family=Noto+Serif+SC:wght@300..900&display=swap" rel="stylesheet">

    <style>
        :root { --bg-color: #1e1e1e; --panel-bg: rgba(30, 30, 30, 0.85); --accent-color: #007AFF; --danger-color: #ff453a; --text-color: #fff; --border-color: #444; }
        
        html, body { 
            height: 100%; width: 100%; 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; 
            background-color: #121212; 
            color: var(--text-color); margin: 0; 
            touch-action: none; 
            -webkit-user-select: none; user-select: none;
        }
        
        #status-indicator { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); font-size: 11px; color: #aaa; background: rgba(30,30,30,0.6); backdrop-filter: blur(10px); padding: 6px 16px; border-radius: 20px; transition: all 0.3s; font-weight: 500; z-index: 10; opacity: 0; pointer-events: none; border: 1px solid rgba(255,255,255,0.1); }
        #status-indicator.visible { opacity: 1; top: 30px; }
        .status-saved { color: #32D74B !important; } .status-saving { color: #FFD700 !important; }

        #canvas-wrapper { 
            width: 100vw; height: 100dvh; 
            overflow: hidden;
            background-color: #121212; 
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex; justify-content: center; align-items: center;
        }
        
        .canvas-container { margin: 0 auto; background: transparent !important; }
        canvas { background: transparent !important; }

        /* Side Bar */
        .side-bar {
            position: fixed; 
            top: 50%; transform: translateY(-50%);
            display: flex; flex-direction: column; gap: 12px;
            z-index: 90;
        }
        .side-btn {
            width: 44px; height: 44px; border-radius: 50%;
            background: var(--panel-bg); backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            color: #ddd; font-size: 20px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .side-btn:hover { background: #444; color: #fff; transform: scale(1.1); }
        .side-btn:active { transform: scale(0.95); }
        .side-btn i { pointer-events: none; }

        /* Bottom Bar */
        .bottom-bar {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 40px; align-items: center;
            padding: 0 20px;
            z-index: 100;
            padding-bottom: env(safe-area-inset-bottom, 0);
            margin-bottom: env(safe-area-inset-bottom, 0);
        }

        .bar-btn-group { position: relative; }

        .main-btn {
            width: 56px; height: 56px; border-radius: 50%;
            background: var(--panel-bg); backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.15);
            color: #fff; font-size: 24px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
        }
        .main-btn:hover { transform: translateY(-4px); border-color: rgba(255,255,255,0.3); }
        .main-btn:active { transform: scale(0.95); }
        .main-btn.accent { background: var(--accent-color); border: none; }
        .main-btn i { pointer-events: none; }

        /* Add Popover Menu */
        #add-popover {
            position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%) scale(0.8);
            background: rgba(40,40,40,0.95); backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 16px; padding: 8px;
            display: flex; flex-direction: column; gap: 8px;
            opacity: 0; pointer-events: none; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            width: 120px;
        }
        #add-popover.active { opacity: 1; pointer-events: auto; transform: translateX(-50%) scale(1); }
        
        .pop-item {
            display: flex; align-items: center; gap: 10px;
            padding: 10px 12px; border-radius: 8px;
            color: #eee; cursor: pointer; transition: background 0.2s;
            font-size: 14px; font-weight: 500;
        }
        .pop-item:hover { background: rgba(255,255,255,0.1); color: #fff; }
        .pop-item i { font-size: 18px; }

        /* Panels */
        #bg-panel { display: none; position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%); background: rgba(30, 30, 30, 0.95); backdrop-filter: blur(20px); border: 1px solid #444; border-radius: 16px; padding: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); z-index: 90; animation: panelUp 0.2s; width: 240px; }
        @keyframes panelUp { from { opacity: 0; transform: translate(-50%, 20px); } to { opacity: 1; transform: translate(-50%, 0); } }
        .panel-title { font-size: 12px; color: #888; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 1px; text-align: center; }
        .bg-options { display: flex; justify-content: space-between; gap: 10px; align-items: center; }
        .bg-option { width: 48px; height: 48px; border-radius: 8px; border: 2px solid #555; cursor: pointer; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; background-size: cover; background-position: center; transition: all 0.2s; }
        .bg-option:hover { border-color: #fff; transform: scale(1.05); }
        .bg-option.add-btn { border: 2px dashed #666; color: #666; font-size: 24px; }
        .color-input-wrapper { background: conic-gradient(red, yellow, lime, cyan, blue, magenta, red); }
        input[type="color"] { opacity: 0; width: 100%; height: 100%; cursor: pointer; position: absolute; top:0; left:0; }
        .bg-preset-grid { width: 48px; height: 48px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 4px; padding: 2px; background: rgba(255,255,255,0.05); border-radius: 8px; box-sizing: border-box; }
        .preset-dot { width: 100%; height: 100%; border-radius: 50%; cursor: pointer; border: 1px solid rgba(255,255,255,0.1); transition: transform 0.2s; }
        .preset-dot:hover { transform: scale(1.4); border-color: white; z-index: 2; box-shadow: 0 2px 5px rgba(0,0,0,0.5); }

        #context-menu { display: none; position: absolute; z-index: 2000; width: 160px; background: rgba(40, 40, 40, 0.98); backdrop-filter: blur(20px); border: 1px solid #555; border-radius: 12px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); padding: 4px; animation: menuFadeIn 0.15s ease-out; }
        @keyframes menuFadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }
        
        .menu-header { font-size: 9px; color: #888; padding: 3px 6px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; display: none; }
        .layer-controls { display: flex; justify-content: space-between; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 3px; margin-bottom: 4px; }
        .layer-btn { width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 6px; cursor: pointer; font-size: 16px; color: #ccc; }
        .layer-btn:hover { background: #555; color: white; }
        .menu-item { display: none; align-items: center; padding: 8px 8px; font-size: 12px; color: #eee; cursor: pointer; border-radius: 6px; transition: background 0.1s; margin-bottom: 1px; }
        .menu-item:hover, .menu-item:active { background: var(--accent-color); color: white; }
        .menu-item.delete { color: var(--danger-color); margin-top: 4px; border-top: 1px solid #555; border-radius: 0 0 8px 8px; }
        .menu-item.delete:hover { background: var(--danger-color); color: white; }
        .menu-icon-span { width: 20px; text-align: center; margin-right: 6px; font-size: 16px; vertical-align: middle; }

        .text-colors-container { display: flex; gap: 4px; padding: 4px; justify-content: space-around; border-bottom: 1px solid #555; margin-bottom: 4px; }
        .text-color-dot { width: 16px; height: 16px; border-radius: 50%; cursor: pointer; border: 1px solid rgba(255,255,255,0.2); transition: transform 0.2s; }
        .text-color-dot:hover { transform: scale(1.2); border-color: white; }

        .align-toolbar { display: flex; gap: 3px; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 3px; margin-bottom: 4px; }
        .align-btn { flex: 1; text-align: center; padding: 5px 0; font-size: 16px; color: #ccc; cursor: pointer; border-radius: 6px; font-weight: bold; letter-spacing: 0; }
        .align-btn:hover { background: #555; color: white; }

        .control-row { display: none; justify-content: space-between; align-items: center; padding: 4px 8px; color: #ccc; font-size: 12px; margin-bottom: 1px; }
        .control-label { flex-grow: 1; opacity: 0.8; font-size: 11px; }
        .control-group { display: flex; gap: 4px; }
        .control-btn { background: rgba(255,255,255,0.1); border-radius: 4px; width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s; font-weight: bold; color: #ddd; font-size: 14px; }
        .control-btn:hover { background: #555; color: white; }
        .control-btn:active { transform: scale(0.9); }

        /* Font List Popup */
        .font-selector-row { display: none; padding: 2px; margin-bottom: 4px; }
        .font-toggle-btn {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; padding: 8px 8px;
            background: rgba(255,255,255,0.05); border-radius: 8px;
            cursor: pointer; color: #ddd; font-size: 12px;
        }
        .font-toggle-btn:hover { background: rgba(255,255,255,0.1); color: white; }
        
        .font-options-list {
            display: none; flex-direction: column; gap: 4px;
            position: absolute; left: 105%; top: 120px; 
            background: rgba(40, 40, 40, 0.98); backdrop-filter: blur(20px);
            border: 1px solid #555; border-radius: 12px;
            padding: 6px; min-width: 100px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            z-index: 2001; 
        }
        .font-options-list.active { display: flex; }
        
        .font-option {
            padding: 8px 12px; font-size: 14px; color: #ccc;
            cursor: pointer; border-radius: 6px;
            text-align: left; white-space: nowrap;
        }
        .font-option:hover { background: var(--accent-color); color: white; }

        .show-always { display: flex !important; } 
        .show-header { display: block !important; }
        
        #confirm-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); backdrop-filter: blur(5px); z-index: 3000; animation: fadeIn 0.2s; }
        .modal-box { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #2c2c2c; border: 1px solid #555; border-radius: 16px; padding: 25px; width: 280px; text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        .modal-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; color: white; }
        .modal-desc { font-size: 14px; color: #aaa; margin-bottom: 20px; line-height: 1.5; }
        .modal-actions { display: flex; gap: 10px; justify-content: center; }
        .modal-btn { flex: 1; padding: 10px; border-radius: 8px; cursor: pointer; border: none; font-size: 14px; font-weight: 600; }
        .modal-btn.cancel { background: #444; color: #fff; }
        .modal-btn.cancel:hover { background: #555; }
        .modal-btn.confirm { background: var(--danger-color); color: white; }
        .modal-btn.confirm:hover { background: #ff5b50; }

        #file-input, #bg-file-input { display: none; }
    </style>
</head>
<body>
    <div id="status-indicator">准备就绪</div>
    <div id="canvas-wrapper"><canvas id="c"></canvas></div>

    <div class="side-bar">
        <div class="side-btn" onclick="addScreen()" title="增加页面"><i class="ri-file-add-line"></i></div>
        <div class="side-btn" onclick="removeScreen()" title="删除页面"><i class="ri-delete-back-2-line"></i></div>
    </div>

    <div class="bottom-bar">
        <div class="bar-btn-group">
            <div id="add-popover">
                <div class="pop-item" onclick="document.getElementById('file-input').click(); toggleAddMenu(false)"><i class="ri-image-add-line"></i> 添加图片</div>
                <div class="pop-item" onclick="addText(); toggleAddMenu(false)"><i class="ri-text"></i> 添加文字</div>
            </div>
            <div class="main-btn accent" onclick="toggleAddMenu()" title="添加内容"><i class="ri-add-line"></i></div>
        </div>

        <div class="bar-btn-group">
            <div class="main-btn" onclick="toggleBgPanel()" title="背景设置"><i class="ri-palette-line"></i></div>
        </div>

        <div class="bar-btn-group" style="display:flex; gap: 10px;">
            <div class="main-btn danger" onclick="showModal()" style="width:44px; height:44px; font-size:20px;" title="清空"><i class="ri-delete-bin-line"></i></div>
            <div class="main-btn" onclick="exportContent()" title="导出"><i class="ri-download-2-line"></i></div>
        </div>
    </div>

    <div id="bg-panel">
        <div class="panel-title">背景设置</div>
        <div class="bg-options">
            <div class="bg-option color-input-wrapper" title="自定义颜色">
                <input type="color" id="bg-picker" value="#ffffff" onchange="changeBackgroundColor(this.value)">
            </div>
            <div class="bg-preset-grid">
                <div class="preset-dot" style="background:#ffffff" onclick="changeBackgroundColor('#ffffff')"></div>
                <div class="preset-dot" style="background:#f2f2f7" onclick="changeBackgroundColor('#f2f2f7')"></div>
                <div class="preset-dot" style="background:#1c1c1e" onclick="changeBackgroundColor('#1c1c1e')"></div>
                <div class="preset-dot" style="background:#fdf6e3" onclick="changeBackgroundColor('#fdf6e3')"></div>
                <div class="preset-dot" style="background:#ffeff0" onclick="changeBackgroundColor('#ffeff0')"></div>
                <div class="preset-dot" style="background:#eef6ff" onclick="changeBackgroundColor('#eef6ff')"></div>
                <div class="preset-dot" style="background:#d4d4d4" onclick="changeBackgroundColor('#d4d4d4')"></div>
                <div class="preset-dot" style="background:#333333" onclick="changeBackgroundColor('#333333')"></div>
                <div class="preset-dot" style="background:#000000" onclick="changeBackgroundColor('#000000')"></div>
            </div>
            <div class="bg-option add-btn" onclick="document.getElementById('bg-file-input').click()"><i class="ri-add-line" style="font-size: 20px;"></i></div>
        </div>
    </div>

    <div id="confirm-modal">
        <div class="modal-box">
            <div class="modal-title">清空画布</div>
            <div class="modal-desc">确定要清空所有内容吗？<br>此操作无法撤销。</div>
            <div class="modal-actions">
                <button class="modal-btn cancel" onclick="closeModal()">取消</button>
                <button class="modal-btn confirm" onclick="executeClear()">确认清空</button>
            </div>
        </div>
    </div>

    <div id="context-menu">
        <div class="menu-header show-header">图层 Layer</div>
        <div class="layer-controls">
            <div class="layer-btn" onclick="menuAction('top')"><i class="ri-arrow-up-double-line"></i></div>
            <div class="layer-btn" onclick="menuAction('up')"><i class="ri-arrow-up-s-line"></i></div>
            <div class="layer-btn" onclick="menuAction('down')"><i class="ri-arrow-down-s-line"></i></div>
            <div class="layer-btn" onclick="menuAction('bottom')"><i class="ri-arrow-down-double-line"></i></div>
        </div>
        
        <div class="menu-item show-always" id="menu-lock" onclick="menuAction('lock-toggle')">
            <i class="menu-icon-span ri-lock-line"></i> <span id="menu-lock-text">锁定</span>
        </div>

        <div class="menu-header image-menu-item">效果 Effect</div>
        <div class="menu-item image-menu-item" onclick="menuAction('flipX')"><i class="menu-icon-span ri-arrow-left-right-line"></i> 水平翻转</div>
        <div class="menu-item image-menu-item" onclick="menuAction('filter-bw')"><i class="menu-icon-span ri-contrast-drop-line"></i> 黑白滤镜</div>
        <div class="menu-item image-menu-item" onclick="menuAction('shadow')"><i class="menu-icon-span ri-drop-line"></i> 投影</div>

        <div class="menu-header text-menu-item">文字设置</div>
        
        <div class="font-selector-row text-menu-item">
            <div class="font-toggle-btn" onclick="toggleFontList()">
                <span>字体 Font</span> <i class="ri-arrow-right-s-line" id="font-arrow-icon"></i>
            </div>
        </div>
        
        <div id="font-options-wrapper" class="font-options-list">
            <div class="font-option" style="font-family: 'Noto Sans SC', sans-serif" onclick="changeFont('\'Noto Sans SC\', sans-serif')">思源黑体</div>
            <div class="font-option" style="font-family: 'Noto Serif SC', serif" onclick="changeFont('\'Noto Serif SC\', serif')">思源宋体</div>
        </div>

        <div class="text-colors-container text-menu-item">
            <div class="text-color-dot" style="background: #000000" onclick="changeTextColor('#000000')"></div>
            <div class="text-color-dot" style="background: #ffffff" onclick="changeTextColor('#ffffff')"></div>
            <div class="text-color-dot" style="background: #FFCC00" onclick="changeTextColor('#FFCC00')"></div>
            <div class="text-color-dot" style="background: #34C759" onclick="changeTextColor('#34C759')"></div>
            <div class="text-color-dot" style="background: #007AFF" onclick="changeTextColor('#007AFF')"></div>
            <div class="text-color-dot" style="background: #FF3B30" onclick="changeTextColor('#FF3B30')"></div>
        </div>
        
        <div class="align-toolbar text-menu-item">
            <div class="align-btn" onclick="menuAction('align-left')"><i class="ri-align-left"></i></div>
            <div class="align-btn" onclick="menuAction('align-center')"><i class="ri-align-center"></i></div>
            <div class="align-btn" onclick="menuAction('align-right')"><i class="ri-align-right"></i></div>
        </div>

        <div class="control-row text-menu-item">
            <span class="control-label">字重 Weight</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('weight-down')"><i class="ri-subtract-line"></i></div>
                <div class="control-btn" onclick="menuAction('weight-up')"><i class="ri-add-line"></i></div>
            </div>
        </div>
        <div class="control-row text-menu-item">
            <span class="control-label">字距 Spacing</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('spacing-down')"><i class="ri-subtract-line"></i></div>
                <div class="control-btn" onclick="menuAction('spacing-up')"><i class="ri-add-line"></i></div>
            </div>
        </div>
        <div class="control-row text-menu-item">
            <span class="control-label">行高 Height</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('line-height-down')"><i class="ri-subtract-line"></i></div>
                <div class="control-btn" onclick="menuAction('line-height-up')"><i class="ri-add-line"></i></div>
            </div>
        </div>

        <div class="menu-item show-always" onclick="menuAction('duplicate')"><i class="menu-icon-span ri-file-copy-line"></i> 复制</div>
        <div class="menu-item delete show-always" onclick="menuAction('delete')"><i class="menu-icon-span ri-delete-bin-line"></i> 删除</div>
    </div>
    
    <input type="file" id="file-input" accept="image/*" multiple onchange="handleFiles(this.files)">
    <input type="file" id="bg-file-input" accept="image/*" onchange="handleBgFile(this.files)">

    <script>
        const SCREEN_WIDTH = 540;
        const SCREEN_HEIGHT = 960;
        let screenCount = 1;
        fabric.textureSize = 2048; 

        const rotateIconImg = new Image();
        rotateIconImg.src = 'rotate.png';
        rotateIconImg.onload = function() { if(canvas) canvas.requestRenderAll(); }

        function renderCustomIcon(ctx, left, top, styleOverride, fabricObject) {
            const size = 20; 
            ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            ctx.beginPath(); ctx.arc(0, 0, size/2, 0, 2 * Math.PI); ctx.fillStyle = "#007AFF"; ctx.fill();
            ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 3; ctx.shadowOffsetY = 1;
            const iconSize = size * 0.7; 
            if (rotateIconImg.complete && rotateIconImg.naturalWidth !== 0) {
                 ctx.drawImage(rotateIconImg, -iconSize/2, -iconSize/2, iconSize, iconSize);
            } else {
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(0,0, 3, 0, 2*Math.PI); ctx.fill();
            }
            ctx.restore();
        }

        fabric.Object.prototype.set({
            snapAngle: 90, snapThreshold: 3,
            cornerStyle: 'circle', cornerColor: '#007AFF', borderColor: '#007AFF',
            transparentCorners: false, borderScaleFactor: 2, cornerSize: 10,
            centeredScaling: false, lockUniScaling: true,
            lockMovementX: false, lockMovementY: false
        });

        fabric.Object.prototype.controls.mtr = new fabric.Control({
            x: 0, y: -0.5, offsetY: -25, 
            actionHandler: fabric.controlsUtils.rotationWithSnapping,
            cursorStyle: 'crosshair', render: renderCustomIcon, actionName: 'rotate'
        });

        const canvas = new fabric.Canvas('c', {
            width: window.innerWidth, height: window.innerHeight,
            backgroundColor: null, 
            preserveObjectStacking: true, 
            fireRightClick: true, stopContextMenu: true,
            selection: false, 
            allowTouchScrolling: false,
            targetFindTolerance: 20 
        });

        let gridLines = [];
        const contextMenu = document.getElementById('context-menu');
        const bgPanel = document.getElementById('bg-panel');
        const statusIndicator = document.getElementById('status-indicator');
        const confirmModal = document.getElementById('confirm-modal');
        const addPopover = document.getElementById('add-popover');
        const sideBar = document.querySelector('.side-bar');

        const DB_NAME = "SparkCanvasDB"; const STORE_NAME = "sessions";
        let db; let saveTimeout;

        let isInternalUpdate = false;
        let currentBgFill = '#ffffff'; 
        let bgRect; 

        function updateWorkspace() {
            isInternalUpdate = true;
            if (bgRect && canvas.contains(bgRect)) canvas.remove(bgRect);
            
            bgRect = new fabric.Rect({
                left: 0, top: 0,
                width: screenCount * SCREEN_WIDTH,
                height: SCREEN_HEIGHT,
                fill: currentBgFill,
                selectable: false, evented: false, 
                isBackground: true 
            });
            canvas.add(bgRect);
            canvas.sendToBack(bgRect);

            canvas.clipPath = new fabric.Rect({
                left: 0, top: 0,
                width: screenCount * SCREEN_WIDTH,
                height: SCREEN_HEIGHT,
                absolutePositioned: false 
            });

            gridLines.forEach(l => canvas.remove(l)); 
            gridLines = [];
            for (let i = 1; i < screenCount; i++) {
                const line = new fabric.Line([i * SCREEN_WIDTH, 0, i * SCREEN_WIDTH, SCREEN_HEIGHT], {
                    stroke: '#007AFF', strokeWidth: 1, strokeDashArray: [5, 5], opacity: 0.3, selectable: false, evented: false, excludeFromExport: true
                });
                canvas.add(line); gridLines.push(line);
            }
            isInternalUpdate = false;
        }

        function updateSideBarPosition() {
            const vpt = canvas.viewportTransform;
            if(!vpt) return;
            const zoom = canvas.getZoom();
            const contentRightEdge = vpt[4] + (screenCount * SCREEN_WIDTH * zoom);
            sideBar.style.left = (contentRightEdge + 15) + 'px'; 
        }

        // V102: Focus on specific page index (Center Align)
        function focusOnPage(index) {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const zoom = canvas.getZoom();
            
            // Calculate Vertical Center (Safety Area above toolbar)
            const toolbar = document.querySelector('.bottom-bar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight + 50 : 100;
            const visualSpaceCenterY = (winH - toolbarHeight) / 2;
            const contentHalfHeight = (SCREEN_HEIGHT * zoom) / 2;
            const targetY = visualSpaceCenterY - contentHalfHeight + 20;

            // Calculate Horizontal Center for specific page
            // Center of Page i = (index * Width) + (Width / 2)
            // We want that center to be at WindowWidth / 2
            const vpt = canvas.viewportTransform;
            vpt[4] = (winW / 2) - ((index * SCREEN_WIDTH + SCREEN_WIDTH / 2) * zoom);
            vpt[5] = targetY;

            canvas.requestRenderAll();
            updateSideBarPosition();
        }

        function initViewport() {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            
            canvas.setWidth(winW);
            canvas.setHeight(winH);

            const toolbar = document.querySelector('.bottom-bar');
            const toolbarHeight = toolbar ? toolbar.offsetHeight + 50 : 100;
            
            const safeW = winW - 60; 
            const safeH = winH - toolbarHeight - 20; 
            
            const scaleX = safeW / SCREEN_WIDTH;
            const scaleY = safeH / SCREEN_HEIGHT;
            let zoom = Math.min(scaleX, scaleY);
            
            if (zoom > 1) zoom = 1; 
            if (zoom < 0.1) zoom = 0.1;
            canvas.setZoom(zoom);

            // Initial focus on first page (or could track current page)
            focusOnPage(0);
            
            updateHitRegions(); 
        }
        
        function updateHitRegions() {
            canvas.forEachObject(obj => obj.setCoords());
        }

        window.addEventListener('resize', () => {
            initViewport(); 
        });

        setTimeout(() => {
            updateWorkspace();
            initViewport();
        }, 100);

        let isDraggingCanvas = false;
        let lastX, lastY;
        let mouseDownPoint = {x:0, y:0};
        let mouseDownTarget = null; 

        // Momentum Variables
        let velocityX = 0, velocityY = 0;
        let lastMoveTime = 0;
        let momentumID = null;

        function getClientPos(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function getBroadType(type) {
            if (type === 'i-text' || type === 'text' || type === 'textbox') return 'text';
            if (type === 'image') return 'image';
            return 'other';
        }

        function updateContextMenuState(target) {
            const lockItemText = document.getElementById('menu-lock-text');
            const lockIcon = document.querySelector('#menu-lock .menu-icon-span');
            
            if (target.lockMovementX) {
                lockItemText.innerText = "解锁";
                lockIcon.className = "menu-icon-span ri-lock-unlock-line"; 
            } else {
                lockItemText.innerText = "锁定";
                lockIcon.className = "menu-icon-span ri-lock-line"; 
            }
        }

        // New Helper: Calculate Canvas Bounds (Center of First Page to Center of Last Page)
        function getCanvasBounds() {
            const winW = window.innerWidth;
            const zoom = canvas.getZoom();
            // Bound Left: When Page 0 is centered
            const maxLeft = (winW / 2) - (SCREEN_WIDTH * zoom / 2);
            // Bound Right: When Last Page is centered
            const minLeft = (winW / 2) - ((screenCount * SCREEN_WIDTH - SCREEN_WIDTH/2) * zoom);
            return { min: minLeft, max: maxLeft };
        }

        // New Helper: Snap Back Animation
        function snapBack() {
            const bounds = getCanvasBounds();
            const currentX = canvas.viewportTransform[4];
            let targetX = currentX;

            if (currentX > bounds.max) targetX = bounds.max;
            else if (currentX < bounds.min) targetX = bounds.min;
            else return; // Inside bounds, no snap needed

            fabric.util.animate({
                startValue: currentX,
                endValue: targetX,
                duration: 400,
                easing: fabric.util.ease.easeOutQuart,
                onChange: function(value) {
                    canvas.viewportTransform[4] = value;
                    canvas.requestRenderAll();
                    updateSideBarPosition();
                },
                onComplete: function() {
                     canvas.setViewportTransform(canvas.viewportTransform);
                     updateHitRegions();
                }
            });
        }

        canvas.on('mouse:down', function(opt) {
            const evt = opt.e;
            const target = opt.target;

            // Momentum: Stop previous animation
            cancelAnimationFrame(momentumID);
            velocityX = 0; velocityY = 0;
            lastMoveTime = Date.now();

            if (addPopover.classList.contains('active')) {
                toggleAddMenu(false);
            }

            if (opt.button === 3) {
                if (target && target !== bgRect) {
                    canvas.setActiveObject(target);
                    openContextMenu(opt);
                }
                return;
            }

            const pos = getClientPos(evt);
            lastX = pos.x; lastY = pos.y;
            mouseDownPoint = { x: pos.x, y: pos.y };

            if (contextMenu.style.display === 'block' && opt.button !== 3) {
                if (!target || target === bgRect) {
                    contextMenu.style.display = 'none';
                    document.getElementById('font-options-wrapper').classList.remove('active');
                    document.getElementById('font-arrow-icon').className = "ri-arrow-right-s-line";
                } else {
                    const currentType = getBroadType(target.type);
                    const menuType = contextMenu.dataset.currentType; 
                    
                    if (currentType !== menuType) {
                        contextMenu.style.display = 'none';
                        document.getElementById('font-options-wrapper').classList.remove('active');
                    } else {
                        updateContextMenuState(target);
                    }
                }
            }

            if (target && target !== bgRect) {
                if (target.lockMovementX) {
                    isDraggingCanvas = true;
                    mouseDownTarget = target; 
                    canvas.discardActiveObject(); 
                    canvas.requestRenderAll();
                } else {
                    isDraggingCanvas = false;
                    mouseDownTarget = null;
                    target.setCoords();
                }
            } else {
                isDraggingCanvas = true;
                mouseDownTarget = null;
            }
            
            if (bgPanel.style.display === 'block') bgPanel.style.display = 'none';
            
            if (target && target !== bgRect && evt.type === 'touchstart') {
                if (target.__corner) return;
                longPressTimer = setTimeout(() => {
                    const active = canvas.getActiveObject();
                    if (isDraggingCanvas && Math.abs(lastX - pos.x) < 5 && Math.abs(lastY - pos.y) < 5) {
                        isDraggingCanvas = false; 
                        canvas.setActiveObject(target); 
                        openContextMenu(opt);
                    } else if (!isDraggingCanvas && active && !active.isMoving && !active.isScaling && !active.isRotating) {
                        openContextMenu(opt);
                    }
                }, 500);
            } else if (!target || target === bgRect) {
                contextMenu.style.display = 'none';
                document.getElementById('font-options-wrapper').classList.remove('active');
            }
        });

        let isObjectMoving = false;
        canvas.on('mouse:move', function(opt) {
            if (isDraggingCanvas) {
                const evt = opt.e;
                const pos = getClientPos(evt);
                if (pos.x === undefined || pos.y === undefined) return;
                
                const now = Date.now();
                const dt = now - lastMoveTime;

                let deltaX = pos.x - lastX;
                let deltaY = pos.y - lastY;

                // Momentum: Calculate velocity
                if (dt > 0) {
                    const newVx = deltaX / dt;
                    const newVy = deltaY / dt;
                    velocityX = velocityX * 0.5 + newVx * 0.5;
                    velocityY = velocityY * 0.5 + newVy * 0.5;
                    lastMoveTime = now;
                }

                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    clearTimeout(longPressTimer);
                }

                const visualHeight = SCREEN_HEIGHT * canvas.getZoom();
                const availableHeight = window.innerHeight - (document.querySelector('.bottom-bar').offsetHeight + 30);
                
                if (visualHeight <= availableHeight) {
                    deltaY = 0; 
                    velocityY = 0; 
                }

                // --- V102-RubberBand: Damping Logic ---
                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                const proposedX = currentX + deltaX;

                if (proposedX > bounds.max) {
                     // Dragging Right (Past Page 0)
                     const overage = proposedX - bounds.max;
                     const resistance = 1 / (1 + Math.abs(overage) * 0.003); 
                     deltaX *= resistance;
                } else if (proposedX < bounds.min) {
                     // Dragging Left (Past Last Page)
                     const overage = bounds.min - proposedX;
                     const resistance = 1 / (1 + Math.abs(overage) * 0.003);
                     deltaX *= resistance;
                }
                // --------------------------------------

                canvas.relativePan({ x: deltaX, y: deltaY });
                updateSideBarPosition();
                
                lastX = pos.x;
                lastY = pos.y;
            } else {
                const active = canvas.getActiveObject();
                if (active && (active.isMoving || active.isScaling || active.isRotating)) {
                    isObjectMoving = true;
                    clearTimeout(longPressTimer);
                }
            }
        });

        canvas.on('mouse:up', function(opt) {
            const evt = opt.e;
            const pos = getClientPos(evt);
            
            if (isDraggingCanvas && mouseDownTarget && mouseDownTarget.lockMovementX) {
                const dist = Math.sqrt(Math.pow(pos.x - mouseDownPoint.x, 2) + Math.pow(pos.y - mouseDownPoint.y, 2));
                if (dist < 5) { 
                    canvas.setActiveObject(mouseDownTarget);
                    canvas.requestRenderAll();
                }
            }

            if (isDraggingCanvas) {
                const timeSinceLastMove = Date.now() - lastMoveTime;
                if (timeSinceLastMove > 100) {
                    velocityX = 0;
                    velocityY = 0;
                }
                
                // --- V102-RubberBand: Check for SnapBack immediately ---
                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                
                if (currentX > bounds.max || currentX < bounds.min) {
                    velocityX = 0; velocityY = 0;
                    snapBack();
                } else {
                    applyMomentum();
                }
                // ----------------------------------------------------
            }

            isDraggingCanvas = false;
            isObjectMoving = false;
            clearTimeout(longPressTimer);
            canvas.setViewportTransform(canvas.viewportTransform); 
            updateSideBarPosition();
            updateHitRegions(); 
        });

        function applyMomentum() {
            const friction = 0.95; 
            const stopThreshold = 0.01;

            function step() {
                if (Math.abs(velocityX) < stopThreshold && Math.abs(velocityY) < stopThreshold) {
                    cancelAnimationFrame(momentumID);
                    return;
                }

                velocityX *= friction;
                velocityY *= friction;

                let panX = velocityX * 16; 
                let panY = velocityY * 16;

                const visualHeight = SCREEN_HEIGHT * canvas.getZoom();
                const availableHeight = window.innerHeight - (document.querySelector('.bottom-bar').offsetHeight + 30);
                if (visualHeight <= availableHeight) {
                    panY = 0;
                }

                // --- V102-RubberBand: Momentum Boundary Check ---
                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                const proposedX = currentX + panX;

                if (proposedX > bounds.max || proposedX < bounds.min) {
                    cancelAnimationFrame(momentumID);
                    snapBack();
                    return;
                }
                // ------------------------------------------------

                canvas.relativePan({ x: panX, y: panY });
                updateSideBarPosition();
                
                momentumID = requestAnimationFrame(step);
            }
            step();
        }

        canvas.on('mouse:wheel', function(opt) {
            opt.e.preventDefault();
            opt.e.stopPropagation();
        });

        let initialDistance = 0;
        let initialZoom = 1;
        let initialObjectScale = 1;
        let activeObjectForPinch = null;
        let pinchMode = null; 

        canvas.upperCanvasEl.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                isDraggingCanvas = false; 
                const pointer0 = canvas.getPointer(e.touches[0]); 
                let target = canvas.findTarget(e); 
                if (target === bgRect) target = null;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                if (target && target === canvas.getActiveObject()) {
                    pinchMode = 'object';
                    initialObjectScale = target.scaleX;
                } else {
                    pinchMode = null; 
                }
                e.preventDefault();
            }
        }, { passive: false });

        canvas.upperCanvasEl.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && initialDistance > 0) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                
                if (pinchMode === 'object') {
                    const target = canvas.getActiveObject();
                    if(target) {
                        const scaleFactor = currentDistance / initialDistance;
                        let newScale = initialObjectScale * scaleFactor;
                        if(newScale < 0.1) newScale = 0.1;
                        target.scale(newScale);
                        target.setCoords();
                        canvas.requestRenderAll();
                    }
                }
            }
        }, { passive: false });
        
        canvas.upperCanvasEl.addEventListener('touchend', function(e) {
            if(e.touches.length < 2) {
                initialDistance = 0;
                pinchMode = null;
                updateHitRegions(); 
            }
        });

        // --- 功能函数 ---

        let longPressTimer;
        const FONT_WEIGHTS = [300, 400, 600, 900];

        function menuAction(action) {
            const obj = canvas.getActiveObject(); if (!obj) return;
            switch(action) {
                case 'lock-toggle':
                    const isLocked = obj.lockMovementX;
                    if (isLocked) {
                        obj.set({
                            lockMovementX: false, lockMovementY: false,
                            lockRotation: false, lockScalingX: false, lockScalingY: false,
                            hasControls: true, borderColor: '#007AFF'
                        });
                    } else {
                        obj.set({
                            lockMovementX: true, lockMovementY: true,
                            lockRotation: true, lockScalingX: true, lockScalingY: true,
                            hasControls: false, borderColor: '#ff453a'
                        });
                    }
                    canvas.requestRenderAll();
                    triggerAutoSave();
                    updateContextMenuState(obj); 
                    break;
                case 'top': obj.bringToFront(); break; case 'bottom': obj.sendToBack(); break;
                case 'up': obj.bringForward(); break; case 'down': obj.sendBackwards(); break;
                case 'delete': canvas.remove(obj); canvas.discardActiveObject(); break;
                case 'duplicate':
                    obj.clone(function(cloned) {
                        canvas.discardActiveObject();
                        cloned.set({ left: obj.left + 20, top: obj.top + 20, evented: true });
                        if(cloned.type === 'i-text' || cloned.type === 'text') cloned.set('objectCaching', false);
                        if (cloned.type === 'activeSelection') {
                            cloned.canvas = canvas;
                            cloned.forEachObject(function(o) { canvas.add(o); });
                            cloned.setCoords();
                        } else { canvas.add(cloned); }
                        canvas.setActiveObject(cloned);
                        canvas.requestRenderAll();
                        triggerAutoSave();
                    });
                    break;
                case 'flipX': if(obj.type === 'image') obj.set('flipX', !obj.flipX); break;
                case 'filter-bw': if (obj.type === 'image') { if (obj.filters && obj.filters.length > 0) { obj.filters = []; } else { obj.filters.push(new fabric.Image.filters.Grayscale()); } obj.applyFilters(); } break;
                case 'shadow': if (obj.type === 'image') { if (obj.shadow) { obj.set('shadow', null); } else { obj.set('shadow', new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 20, offsetX: 10, offsetY: 10 })); } } break;
                case 'spacing-up': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.charSpacing || 0; obj.set('charSpacing', val + 50); } break;
                case 'spacing-down': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.charSpacing || 0; obj.set('charSpacing', val - 50); } break;
                case 'line-height-up': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.lineHeight || 1.16; obj.set('lineHeight', val + 0.1); } break;
                case 'line-height-down': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.lineHeight || 1.16; if(val > 0.5) obj.set('lineHeight', val - 0.1); } break;
                case 'align-left': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'left'); break;
                case 'align-center': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'center'); break;
                case 'align-right': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'right'); break;
                case 'weight-up': if (obj.type === 'i-text' || obj.type === 'text') { let current = parseInt(obj.fontWeight) || 600; if(current === 'normal') current = 400; if(current === 'bold') current = 700; let next = FONT_WEIGHTS.find(w => w > current); if (!next) next = FONT_WEIGHTS[FONT_WEIGHTS.length - 1]; obj.set('fontWeight', next); } break;
                case 'weight-down': if (obj.type === 'i-text' || obj.type === 'text') { let current = parseInt(obj.fontWeight) || 600; if(current === 'normal') current = 400; if(current === 'bold') current = 700; let prev = [...FONT_WEIGHTS].reverse().find(w => w < current); if (!prev) prev = FONT_WEIGHTS[0]; obj.set('fontWeight', prev); } break;
            }
            if(bgRect) canvas.sendToBack(bgRect);
            bringGridToFront(); canvas.renderAll(); triggerAutoSave();
            
            const keepOpen = [
                'weight-up', 'weight-down', 
                'spacing-up', 'spacing-down', 
                'line-height-up', 'line-height-down', 
                'align-left', 'align-center', 'align-right',
                'top', 'bottom', 'up', 'down',
                'lock-toggle' 
            ];
            
            if (!keepOpen.includes(action)) {
                contextMenu.style.display = 'none';
                document.getElementById('font-options-wrapper').classList.remove('active');
                document.getElementById('font-arrow-icon').className = "ri-arrow-right-s-line";
            }
        }

        function openContextMenu(opt) {
            const target = opt.target || canvas.getActiveObject();
            if(!target || target === bgRect) return;
            
            canvas.setActiveObject(target);
            const type = target.type;
            const imageItems = document.querySelectorAll('.image-menu-item');
            const textItems = document.querySelectorAll('.text-menu-item');

            contextMenu.dataset.currentType = getBroadType(type);
            updateContextMenuState(target);

            // Reset font menu state
            document.getElementById('font-options-wrapper').classList.remove('active');
            document.getElementById('font-arrow-icon').className = "ri-arrow-right-s-line";

            if (type === 'image') {
                imageItems.forEach(el => el.style.display = 'flex');
                textItems.forEach(el => el.style.display = 'none');
            } else if (type === 'i-text' || type === 'text') {
                imageItems.forEach(el => el.style.display = 'none');
                textItems.forEach(el => el.style.display = 'flex'); 
            } else {
                imageItems.forEach(el => el.style.display = 'none');
                textItems.forEach(el => el.style.display = 'none');
            }

            let clientX, clientY;
            if (opt.e.changedTouches && opt.e.changedTouches[0]) {
                clientX = opt.e.changedTouches[0].clientX;
                clientY = opt.e.changedTouches[0].clientY;
            } else {
                clientX = opt.e.clientX;
                clientY = opt.e.clientY;
            }

            contextMenu.style.display = 'block';
            const menuW = contextMenu.offsetWidth;
            const menuH = contextMenu.offsetHeight;

            let left = clientX + 10;
            let top = clientY - (menuH / 2);

            if (left + menuW > window.innerWidth) left = clientX - menuW - 10;
            if (top + menuH > window.innerHeight) top = window.innerHeight - menuH - 10;
            if (top < 10) top = 10;

            contextMenu.style.left = left + 'px';
            contextMenu.style.top = top + 'px';
            bgPanel.style.display = 'none';
        }

        function toggleAddMenu(forceState) {
            if (forceState === undefined) {
                addPopover.classList.toggle('active');
            } else if (forceState) {
                addPopover.classList.add('active');
            } else {
                addPopover.classList.remove('active');
            }
        }

        function toggleFontList() {
            const list = document.getElementById('font-options-wrapper');
            const arrow = document.getElementById('font-arrow-icon');
            list.classList.toggle('active');
            if(list.classList.contains('active')) {
                arrow.className = "ri-arrow-left-s-line";
            } else {
                arrow.className = "ri-arrow-right-s-line";
            }
        }

        function showModal() { confirmModal.style.display = 'block'; }
        function closeModal() { confirmModal.style.display = 'none'; }
        
        function executeClear() {
            canvas.clear(); 
            bgRect = null;
            gridLines = [];
            screenCount = 1; 
            currentBgFill = '#ffffff'; 
            updateWorkspace();
            initViewport();
            if(db) { const tx = db.transaction(STORE_NAME, "readwrite"); tx.objectStore(STORE_NAME).delete("last_session"); }
            statusIndicator.innerText = "画布已重置"; statusIndicator.classList.add('visible');
            closeModal();
        }

        function changeFont(fontFamily) {
            const activeObj = canvas.getActiveObject();
            if (activeObj && (activeObj.type === 'i-text' || activeObj.type === 'text')) {
                activeObj.set("fontFamily", fontFamily);
                activeObj.set("fontWeight", 600);
                canvas.requestRenderAll();
                triggerAutoSave();
                toggleFontList();
            }
        }

        function changeTextColor(color) {
            const activeObj = canvas.getActiveObject();
            if (activeObj && (activeObj.type === 'i-text' || activeObj.type === 'text')) {
                activeObj.set("fill", color);
                canvas.requestRenderAll();
                triggerAutoSave();
            }
        }

        function addText() {
            const center = canvas.getVpCenter();
            const selectedFont = "'Noto Sans SC', sans-serif";
            const text = new fabric.IText('双击编辑', {
                left: center.x, top: center.y,
                fontFamily: selectedFont, 
                fontWeight: 600, 
                fill: '#000000', 
                fontSize: 40,
                originX: 'center', 
                originY: 'center',
                textAlign: 'left',
                charSpacing: 0,
                shadow: null,
                objectCaching: false 
            });
            text.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
            canvas.add(text);
            canvas.setActiveObject(text);
            triggerAutoSave();
        }

        // V102: Focus on Page Functionality
        function addScreen() { 
            screenCount++; 
            updateWorkspace(); 
            canvas.requestRenderAll(); 
            triggerAutoSave(); 
            // Focus on the new page (index = count - 1)
            focusOnPage(screenCount - 1);
        }
        function removeScreen() { 
            if (screenCount > 1) { 
                screenCount--; 
                updateWorkspace(); 
                canvas.requestRenderAll(); 
                triggerAutoSave(); 
                // Focus on the last remaining page
                focusOnPage(screenCount - 1);
            } 
        }

        function toggleBgPanel() {
            const isVisible = bgPanel.style.display === 'block';
            bgPanel.style.display = isVisible ? 'none' : 'block';
        }

        function changeBackgroundColor(color) {
            currentBgFill = color;
            if(bgRect) {
                bgRect.set('fill', color);
                canvas.requestRenderAll();
                triggerAutoSave();
            }
        }

        function handleFiles(files) {
            if (!files || !files[0]) return;
            const center = canvas.getVpCenter();
            Array.from(files).forEach(file => {
                const reader = new FileReader();
                reader.onload = (f) => {
                    fabric.Image.fromURL(f.target.result, (img) => {
                        if (img.width > SCREEN_WIDTH) img.scaleToWidth(SCREEN_WIDTH * 0.8);
                        const offsetX = (Math.random() * 40 - 20);
                        const offsetY = (Math.random() * 40 - 20);
                        img.set({ left: center.x - (img.getScaledWidth()/2) + offsetX, top: center.y - (img.getScaledHeight()/2) + offsetY });
                        img.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                        canvas.add(img); 
                        canvas.setActiveObject(img); 
                        bringGridToFront(); 
                        triggerAutoSave();
                        canvas.requestRenderAll(); 
                    });
                };
                reader.readAsDataURL(file);
            });
            document.getElementById('file-input').value = '';
        }

        function handleBgFile(files) {
            if (!files || !files[0]) return;
            const reader = new FileReader();
            reader.onload = function(f) { applyPattern(f.target.result); };
            reader.readAsDataURL(files[0]);
            document.getElementById('bg-file-input').value = '';
        }

        function applyPattern(imgSrc) {
            fabric.util.loadImage(imgSrc, function(img) {
                if(!img) return;
                const pattern = new fabric.Pattern({ source: img, repeat: 'repeat' });
                currentBgFill = pattern;
                if(bgRect) {
                    bgRect.set('fill', pattern);
                    canvas.requestRenderAll();
                    triggerAutoSave();
                }
            });
        }

        let ctxLines = [];
        canvas.on('object:moving', function(e) {
            const obj = e.target;
            const threshold = 15; 
            ctxLines.forEach(line => canvas.remove(line)); ctxLines = [];
            
            const objCenter = obj.getCenterPoint();
            let finalX = objCenter.x;
            let finalY = objCenter.y;
            
            const pageIndex = Math.floor((obj.left + obj.width * obj.scaleX / 2) / SCREEN_WIDTH);
            const screenCenterX = pageIndex * SCREEN_WIDTH + SCREEN_WIDTH / 2;
            const screenCenterY = SCREEN_HEIGHT / 2;

            let snappedX = false, snappedY = false;

            if (Math.abs(objCenter.x - screenCenterX) < threshold) {
                finalX = screenCenterX;
                drawGuideline(screenCenterX, 0, screenCenterX, SCREEN_HEIGHT);
                snappedX = true;
            }
            if (Math.abs(objCenter.y - screenCenterY) < threshold) {
                finalY = screenCenterY;
                drawGuideline(pageIndex * SCREEN_WIDTH, screenCenterY, (pageIndex + 1) * SCREEN_WIDTH, screenCenterY);
                snappedY = true;
            }

            if (!snappedX || !snappedY) {
                canvas.getObjects().forEach(target => {
                    if (target === obj || target === bgRect || target.excludeFromExport || !target.visible) return;
                    const tCenter = target.getCenterPoint();
                    if (!snappedX && Math.abs(objCenter.x - tCenter.x) < threshold) {
                        finalX = tCenter.x;
                        drawGuideline(tCenter.x, Math.min(obj.top, target.top)-50, tCenter.x, Math.max(obj.top+obj.height*obj.scaleY, target.top+target.height*target.scaleY)+50);
                        snappedX = true;
                    }
                    if (!snappedY && Math.abs(objCenter.y - tCenter.y) < threshold) {
                        finalY = tCenter.y;
                        drawGuideline(Math.min(obj.left, target.left)-50, tCenter.y, Math.max(obj.left+obj.width*obj.scaleX, target.left+target.width*target.scaleX)+50, tCenter.y);
                        snappedY = true;
                    }
                });
            }
            obj.setPositionByOrigin(new fabric.Point(finalX, finalY), 'center', 'center');
            canvas.requestRenderAll();
        });
        
        canvas.on('mouse:up', function() { 
            ctxLines.forEach(line => canvas.remove(line)); 
            ctxLines = []; 
            canvas.requestRenderAll(); 
        });

        function drawGuideline(x1, y1, x2, y2) {
            const line = new fabric.Line([x1, y1, x2, y2], { 
                stroke: '#ff0077', strokeWidth: 1, strokeDashArray: [4, 4], 
                selectable: false, evented: false, excludeFromExport: true 
            });
            canvas.add(line); ctxLines.push(line);
        }

        function initDB() {
            try {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => { db = e.target.result; if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME); };
                request.onsuccess = (e) => { db = e.target.result; loadState(); };
            } catch(e) { console.log("DB Error", e); }
        }
        function saveState() {
            if (!db || isInternalUpdate) return;
            statusIndicator.innerText = "保存中..."; statusIndicator.classList.add('visible', 'status-saving');
            canvas.clipPath = null;
            const json = canvas.toJSON(['isBackground', 'lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'hasControls', 'borderColor']);
            updateWorkspace(); 
            const saveData = { id: "autosave", canvas: json, screenCount: screenCount, bgFill: currentBgFill, updated: new Date().getTime() };
            const tx = db.transaction(STORE_NAME, "readwrite");
            tx.objectStore(STORE_NAME).put(saveData, "last_session");
            tx.oncomplete = () => { 
                statusIndicator.innerText = "已自动保存"; statusIndicator.classList.remove('status-saving'); statusIndicator.classList.add('status-saved');
                setTimeout(() => statusIndicator.classList.remove('visible'), 2000);
            };
        }
        function loadState() {
            const tx = db.transaction(STORE_NAME, "readonly");
            tx.objectStore(STORE_NAME).get("last_session").onsuccess = (e) => {
                const data = e.target.result;
                if (data) {
                    screenCount = data.screenCount || 1; 
                    canvas.loadFromJSON(data.canvas, () => {
                        const objectsToRemove = [];
                        canvas.getObjects().forEach(obj => {
                            if (obj.isBackground || (obj.type === 'rect' && obj.width >= SCREEN_WIDTH && obj.top === 0 && obj.left === 0)) {
                                currentBgFill = obj.fill; 
                                objectsToRemove.push(obj); 
                            }
                        });
                        objectsToRemove.forEach(obj => canvas.remove(obj));
                        updateWorkspace(); 
                        canvas.getObjects().forEach(obj => { 
                            if(obj === bgRect) return;
                            if(obj.type === 'image') {
                                obj.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                                obj.set('noScaleCache', false); 
                            } else if (obj.type === 'i-text' || obj.type === 'text') {
                                obj.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                                obj.set('shadow', null);
                                obj.set('objectCaching', false);
                            }
                            if (obj.lockMovementX) {
                                obj.set({ hasControls: false, borderColor: '#ff453a' });
                            }
                        });
                        drawGrid(); 
                        initViewport(); 
                        statusIndicator.innerText = "已恢复进度"; statusIndicator.classList.add('visible');
                        setTimeout(() => statusIndicator.classList.remove('visible'), 2000);
                    });
                } else { updateWorkspace(); drawGrid(); initViewport(); }
            };
        }
        function triggerAutoSave() {
            if(isInternalUpdate) return;
            clearTimeout(saveTimeout);
            statusIndicator.innerText = "修改中..."; statusIndicator.classList.add('visible'); statusIndicator.classList.remove('status-saved');
            saveTimeout = setTimeout(saveState, 1000);
        }
        canvas.on('object:modified', triggerAutoSave); canvas.on('object:added', triggerAutoSave); canvas.on('object:removed', triggerAutoSave);
        
        function drawGrid() {
            gridLines.forEach(l => canvas.remove(l)); gridLines = [];
            for (let i = 1; i < screenCount; i++) {
                const line = new fabric.Line([i * SCREEN_WIDTH, 0, i * SCREEN_WIDTH, SCREEN_HEIGHT], {
                    stroke: '#007AFF', strokeWidth: 1, strokeDashArray: [5, 5], opacity: 0.3, selectable: false, evented: false, excludeFromExport: true
                });
                canvas.add(line); gridLines.push(line);
            }
            bringGridToFront();
        }
        function bringGridToFront() { gridLines.forEach(l => l.bringToFront()); }

        async function exportContent() {
            statusIndicator.innerText = "准备导出..."; statusIndicator.classList.add('visible', 'status-saving');
            const originalVpt = canvas.viewportTransform.slice();
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            canvas.setWidth(screenCount * SCREEN_WIDTH);
            canvas.setHeight(SCREEN_HEIGHT);
            gridLines.forEach(l => l.visible = false);
            canvas.clipPath = null; canvas.renderAll();

            const blobs = [];
            for (let i = 0; i < screenCount; i++) {
                const dataURL = canvas.toDataURL({ format: 'png', quality: 1, multiplier: 2, left: i * SCREEN_WIDTH, top: 0, width: SCREEN_WIDTH, height: SCREEN_HEIGHT });
                const blob = await (await fetch(dataURL)).blob();
                blobs.push(blob);
            }

            let shareSuccess = false;
            // V104 Modification: Only attempt share on Mobile devices
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            try {
                if (isMobile && navigator.share && navigator.canShare) {
                    const files = blobs.map((blob, i) => new File([blob], `spark_slice_${i+1}.png`, { type: 'image/png' }));
                    if (navigator.canShare({ files })) {
                        statusIndicator.innerText = "调起分享...";
                        await navigator.share({ files: files, title: 'Spark Canvas', text: '由 Spark Canvas 生成' });
                        shareSuccess = true;
                        statusIndicator.innerText = "已完成"; statusIndicator.classList.remove('status-saving'); statusIndicator.classList.add('status-saved');
                    }
                }
            } catch (err) { console.log("Share skipped/cancelled", err); }

            // Fallback (or default for Desktop)
            if (!shareSuccess) {
                statusIndicator.innerText = "开始下载...";
                for (let i = 0; i < blobs.length; i++) {
                    statusIndicator.innerText = `下载中 ${i+1}/${blobs.length}`;
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blobs[i]); a.download = `spark_slice_${i + 1}.png`;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                    if (i < blobs.length - 1) await new Promise(r => setTimeout(r, 1500));
                }
                statusIndicator.innerText = "下载完成"; statusIndicator.classList.remove('status-saving'); statusIndicator.classList.add('status-saved');
            }
            
            setTimeout(() => statusIndicator.classList.remove('visible'), 2000);
            canvas.setViewportTransform(originalVpt); canvas.setWidth(originalWidth); canvas.setHeight(originalHeight);
            gridLines.forEach(l => l.visible = true); updateWorkspace(); canvas.requestRenderAll();
        }
        
        initDB();
    </script>
</body>
</html>

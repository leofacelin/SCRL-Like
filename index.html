<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Spark Canvas - V1.6 (多选最终修复版)</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100..900&family=Noto+Serif+SC:wght@100..900&family=Outfit:wght@100..900&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>

    <style>
        :root { 
            --bg-color: #121212; 
            /* 玻璃拟态变量 */
            --glass-bg: rgba(30, 30, 30, 0.65); 
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.05);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            
            --accent-color: #0A84FF; 
            --danger-color: #FF453A; 
            --text-main: #FFFFFF;
            --text-sub: #8E8E93;
        }
        
        html, body { 
            height: 100%; width: 100%; 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            overflow: hidden; 
            font-family: "Outfit", "Noto Sans SC", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            background-color: var(--bg-color); 
            color: var(--text-main); margin: 0; 
            touch-action: none; 
            -webkit-user-select: none; user-select: none;
        }

        /* 启动页样式 */
        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-color);
            z-index: 99999;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 0.6s ease-out, visibility 0.6s;
        }
        
        #splash-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .splash-content {
            text-align: center;
            animation: breathe 3s infinite ease-in-out;
        }

        .splash-title {
            font-family: 'Outfit', sans-serif;
            font-size: 32px;
            font-weight: 700;
            color: #fff;
            letter-spacing: 1px;
            text-shadow: 0 0 20px rgba(255,255,255,0.1);
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        #status-indicator { display: none !important; }

        #canvas-wrapper { 
            width: 100vw; height: 100dvh; 
            overflow: hidden;
            background-color: var(--bg-color); 
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex; justify-content: center; align-items: center;
        }
        
        .canvas-container { margin: 0 auto; background: transparent !important; }
        canvas { background: transparent !important; }

        /* --- 玻璃拟态基础类 --- */
        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            box-sizing: border-box;
        }

        /* 侧边栏样式 */
        .side-glass-capsule {
            background: var(--glass-bg);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            box-sizing: border-box;
            border-radius: 18px; 
            padding: 5px; 
            display: flex; 
            flex-direction: column; 
            gap: 6px;
            z-index: 90;
        }

        .side-bar {
            position: fixed; top: 50%; transform: translateY(-50%);
        }

        .side-bar-bottom {
            position: fixed; 
        }

        .side-btn {
            width: 36px; height: 36px;
            border-radius: 12px;
            display: flex; align-items: center; justify-content: center;
            font-size: 18px;
            color: var(--text-sub);
            cursor: pointer; 
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 1px solid transparent;
        }
        
        .side-btn:hover { 
            color: var(--text-main); 
            background: var(--glass-highlight);
            transform: scale(1.15);
            border-color: rgba(255,255,255,0.1);
        }
        .side-btn:active { transform: scale(0.9); }

        .side-btn.danger { color: #666; }
        .side-btn.danger:hover { background: rgba(255, 69, 58, 0.15); color: var(--danger-color); border-color: var(--danger-color); }

        /* V3.8 底部 UI 包装器 */
        .bottom-ui-wrapper {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            display: flex;
            align-items: center;
            justify-content: center; /* 确保子元素整体居中 */
            gap: 16px; /* Shift键和Dock之间的间距 */
            z-index: 100;
            width: 100%; /* 宽度铺满以支持居中计算 */
            pointer-events: none; /* 让 wrapper 不遮挡下方点击，子元素开启 */
        }

        /* 底部 Dock 样式 */
        .bottom-dock-container {
            position: relative; /* 相对 wrapper 定位 */
            left: auto; bottom: auto; transform: none;
            padding: 6px 12px;
            border-radius: 24px;
            display: flex; 
            align-items: center; 
            gap: 12px;
            margin-bottom: 0;
            pointer-events: auto; /* 恢复点击 */
        }

        .dock-btn {
            width: 48px; height: 48px;
            border-radius: 14px; 
            display: flex; align-items: center; justify-content: center;
            font-size: 22px; color: var(--text-main);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 1px solid transparent;
        }

        .dock-btn:hover { background: var(--glass-highlight); transform: scale(1.15); }
        .dock-btn:active { transform: scale(0.9); }

        /* V1.4: 独立虚拟 Shift 键 (缩小尺寸以匹配 Dock) */
        #virtual-shift-btn {
            width: 48px; height: 48px; 
            border-radius: 14px; /* 与 dock 按钮圆角一致 */
            background: var(--glass-bg);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            color: var(--text-sub);
            display: flex; align-items: center; justify-content: center;
            font-size: 22px;
            transition: all 0.1s;
            box-shadow: var(--glass-shadow);
            cursor: pointer;
            pointer-events: auto; /* 恢复点击 */
        }

        /* 激活状态 */
        #virtual-shift-btn.active {
            background-color: var(--accent-color);
            color: white !important;
            transform: scale(0.95);
            border-color: var(--accent-color);
            box-shadow: 0 0 15px rgba(10, 132, 255, 0.4);
        }

        /* V1.4 关键更新: 桌面端隐藏虚拟 Shift 键 */
        @media (min-width: 768px) {
            #virtual-shift-btn {
                display: none !important;
            }
        }

        /* 背景设置面板 */
        #bg-panel { 
            display: none; position: absolute; left: 50%; transform: translateX(-50%); 
            border-radius: 20px; padding: 20px; 
            z-index: 90; animation: panelUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); width: 260px; 
            bottom: calc(80px + env(safe-area-inset-bottom, 0px));
        }
        @keyframes panelUp { from { opacity: 0; transform: translate(-50%, 20px) scale(0.95); } to { opacity: 1; transform: translate(-50%, 0) scale(1); } }
        
        .panel-title { font-size: 11px; color: #e0e0e0; margin-bottom: 12px; text-transform: uppercase; letter-spacing: 1px; text-align: center; font-weight: 700; }
        
        .bg-options { display: flex; justify-content: space-between; gap: 12px; align-items: center; }
        .bg-option { width: 52px; height: 52px; border-radius: 14px; border: 2px solid #444; cursor: pointer; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; background-size: cover; background-position: center; transition: all 0.2s; }
        .bg-option:hover { border-color: #fff; transform: scale(1.05); }
        .bg-option.add-btn { border: 2px dashed #555; color: #555; font-size: 24px; }
        .bg-option.add-btn:hover { border-color: #888; color: #888; }
        
        .bg-preset-grid { width: 52px; height: 52px; display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(3, 1fr); gap: 4px; padding: 4px; background: rgba(255,255,255,0.05); border-radius: 14px; box-sizing: border-box; }
        .preset-dot { width: 100%; height: 100%; border-radius: 4px; cursor: pointer; border: 1px solid rgba(255,255,255,0.1); transition: transform 0.2s; }
        .preset-dot:hover { transform: scale(1.2); border-color: white; z-index: 2; }

        /* 上下文菜单 */
        #context-menu { 
            display: none; position: absolute; z-index: 2000; width: 170px; 
            border-radius: 16px; padding: 6px; 
            animation: menuFadeIn 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); 
        }
        @keyframes menuFadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        
        .menu-header { font-size: 10px; color: #e0e0e0; padding: 4px 8px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; font-weight: 700; display: none; }
        
        .layer-controls { display: flex; justify-content: space-between; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 4px; margin-bottom: 6px; }
        .layer-btn { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; cursor: pointer; font-size: 18px; color: #ccc; transition: background 0.2s; }
        .layer-btn:hover { background: rgba(255,255,255,0.15); color: white; }
        
        .menu-item { display: none; align-items: center; padding: 10px 10px; font-size: 13px; color: #eee; cursor: pointer; border-radius: 10px; transition: background 0.1s; margin-bottom: 2px; font-weight: 500; }
        .menu-item:hover, .menu-item:active { background: var(--accent-color); color: white; }
        .menu-item.delete { color: var(--danger-color); margin-top: 6px; border-top: 1px solid rgba(255,255,255,0.08); border-radius: 0 0 10px 10px; padding-top: 12px; }
        .menu-item.delete:hover { background: var(--danger-color); color: white; }
        .menu-icon-span { width: 24px; text-align: center; margin-right: 10px; font-size: 18px; }

        .text-colors-container { display: flex; gap: 6px; padding: 8px 4px; justify-content: space-around; border-bottom: 1px solid rgba(255,255,255,0.08); margin-bottom: 6px; }
        
        .text-color-dot { 
            width: 18px; height: 18px; 
            border-radius: 50%; 
            cursor: pointer; 
            border: 2px solid rgba(255,255,255,0.1); 
            transition: transform 0.2s; 
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .text-color-dot:hover { transform: scale(1.2); border-color: white; }

        .align-toolbar { display: flex; gap: 4px; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 4px; margin-bottom: 6px; }
        .align-btn { flex: 1; text-align: center; padding: 6px 0; font-size: 18px; color: #ccc; cursor: pointer; border-radius: 8px; transition: background 0.2s; }
        .align-btn:hover { background: rgba(255,255,255,0.15); color: white; }

        .control-row { display: none; justify-content: space-between; align-items: center; padding: 6px 10px; color: #ccc; font-size: 12px; margin-bottom: 2px; }
        .control-label { flex-grow: 1; opacity: 0.7; font-size: 12px; font-weight: 500; }
        .control-group { display: flex; gap: 6px; }
        .control-btn { background: rgba(255,255,255,0.1); border-radius: 6px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s; font-weight: bold; color: #ddd; font-size: 16px; }
        .control-btn:hover { background: white; color: black; }
        .control-btn:active { transform: scale(0.9); }

        .font-selector-row { display: none; padding: 2px; margin-bottom: 6px; }
        .font-toggle-btn, .filter-toggle-btn { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 10px 10px; background: rgba(255,255,255,0.05); border-radius: 10px; cursor: pointer; color: #ddd; font-size: 13px; font-weight: 500; transition: background 0.2s; }
        .font-toggle-btn:hover, .filter-toggle-btn:hover { background: rgba(255,255,255,0.15); color: white; }

        .popup-options-list {
             display: none; flex-direction: column; gap: 4px;
             position: absolute; 
             left: calc(105% - 100px); 
             top: 100px;
             border-radius: 14px; padding: 6px; min-width: 110px;
             z-index: 2001;
        }
        .popup-options-list.active { display: flex; }
        .popup-option { padding: 10px 14px; font-size: 14px; color: #ccc; cursor: pointer; border-radius: 8px; text-align: left; white-space: nowrap; transition: background 0.2s; }
        .popup-option:hover { background: var(--accent-color); color: white; }

        .show-always { display: flex !important; }
        .show-header { display: block !important; }

        /* 模态框 */
        #confirm-modal, #info-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); z-index: 3000; animation: fadeIn 0.3s; }

        .modal-box { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: #222; border: 1px solid #444; 
            border-radius: 16px; padding: 15px; 
            width: 240px; max-width: 85%; 
            text-align: center; 
            box-shadow: 0 25px 60px rgba(0,0,0,0.6); 
            animation: popIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes popIn { from { opacity: 0; transform: translate(-50%, -40%) scale(0.9); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }

        .modal-title { font-size: 18px; font-weight: 700; margin-bottom: 12px; color: white; letter-spacing: 0.5px; }
        .modal-desc { font-size: 14px; color: #999; margin-bottom: 24px; line-height: 1.5; }
        .modal-actions { display: flex; gap: 12px; justify-content: center; }
        
        .modal-btn { 
            flex: 1; padding: 12px; border-radius: 10px; 
            cursor: pointer; border: none; font-size: 14px; font-weight: 600; 
            transition: transform 0.1s; 
        }
        .modal-btn:active { transform: scale(0.95); }
        .modal-btn.cancel { background: #3a3a3c; color: #fff; }
        .modal-btn.cancel:hover { background: #48484a; }
        .modal-btn.confirm { background: var(--danger-color); color: white; }
        .modal-btn.confirm:hover { background: #ff5b50; }
        .modal-btn.primary { background: var(--accent-color); color: white; }
        .modal-btn.primary:hover { background: #0062cc; }

        /* 信息列表 */
        .info-list { text-align: left; font-size: 14px; color: #bbb; margin-bottom: 25px; padding: 0 5px; }
        .info-item { display: flex; align-items: center; gap: 16px; margin-bottom: 16px; }
        .info-icon { font-size: 32px; width: 32px; text-align: center; color: var(--accent-color); flex-shrink: 0; }
        
        .modal-footer { margin-top: 25px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .social-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 8px; }
        .social-icon { font-size: 20px; color: #666; cursor: pointer; transition: all 0.2s; text-decoration: none; }
        .social-icon:hover { color: var(--text-main); transform: scale(1.1); }
        .made-with { font-size: 10px; color: #555; display: flex; align-items: center; justify-content: center; gap: 3px; }

        #file-input, #bg-file-input { display: none; }
    </style>
</head>
<body>

    <div id="splash-screen">
        <div class="splash-content">
            <div class="splash-title">Spark Canvas</div>
        </div>
    </div>

    <script>
        if (sessionStorage.getItem('spark_session_active')) {
            document.getElementById('splash-screen').style.display = 'none';
        } else {
            sessionStorage.setItem('spark_session_active', 'true');
        }
    </script>

    <div id="status-indicator">准备就绪</div>
    <div id="canvas-wrapper"><canvas id="c"></canvas></div>

    <div class="side-bar side-glass-capsule">
        <div class="side-btn" onclick="addScreen()" title="增加页面"><i class="ri-file-add-line"></i></div>
        <div class="side-btn" onclick="removeScreen()" title="删除页面"><i class="ri-delete-back-2-line"></i></div>
    </div>

    <div class="side-bar-bottom side-glass-capsule">
        <div class="side-btn" onclick="showInfoModal()" title="操作指南"><i class="ri-information-line"></i></div>
        <div class="side-btn danger" onclick="showModal()" title="清空"><i class="ri-delete-bin-line"></i></div>
    </div>

    <div class="bottom-ui-wrapper">
        <div id="virtual-shift-btn" title="多选模式 (按住)">
            <i class="ri-checkbox-multiple-blank-line"></i>
        </div>

        <div class="bottom-dock-container glass-panel">
            <div class="dock-btn" onclick="document.getElementById('file-input').click()" title="添加图片"><i class="ri-image-add-line"></i></div>
            <div class="dock-btn" onclick="addText()" title="添加文字"><i class="ri-text"></i></div>
            <div class="dock-btn" onclick="toggleBgPanel()" title="背景设置"><i class="ri-palette-line"></i></div>
            <div class="dock-btn" onclick="exportContent()" title="导出"><i class="ri-download-2-line"></i></div>
        </div>
    </div>

    <div id="bg-panel" class="glass-panel">
        <div class="panel-title">背景设置</div>
        <div class="bg-options">
            <div class="bg-option color-input-wrapper" title="自定义颜色">
                <input type="color" id="bg-picker" value="#ffffff" onchange="changeBackgroundColor(this.value)">
            </div>
            <div class="bg-preset-grid">
                <div class="preset-dot" style="background:#ffffff" onclick="changeBackgroundColor('#ffffff')"></div>
                <div class="preset-dot" style="background:#f2f2f7" onclick="changeBackgroundColor('#f2f2f7')"></div>
                <div class="preset-dot" style="background:#1c1c1e" onclick="changeBackgroundColor('#1c1c1e')"></div>
                <div class="preset-dot" style="background:#fdf6e3" onclick="changeBackgroundColor('#fdf6e3')"></div>
                <div class="preset-dot" style="background:#ffeff0" onclick="changeBackgroundColor('#ffeff0')"></div>
                <div class="preset-dot" style="background:#eef6ff" onclick="changeBackgroundColor('#eef6ff')"></div>
                <div class="preset-dot" style="background:#d4d4d4" onclick="changeBackgroundColor('#d4d4d4')"></div>
                <div class="preset-dot" style="background:#333333" onclick="changeBackgroundColor('#333333')"></div>
                <div class="preset-dot" style="background:#000000" onclick="changeBackgroundColor('#000000')"></div>
            </div>
            <div class="bg-option add-btn" onclick="document.getElementById('bg-file-input').click()"><i class="ri-add-line"></i></div>
        </div>
    </div>

    <div id="confirm-modal">
        <div class="modal-box">
            <div class="modal-title">清空画布</div>
            <div class="modal-desc">确定要清空所有内容吗？<br>此操作无法撤销。</div>
            <div class="modal-actions">
                <button class="modal-btn cancel" onclick="closeModal()">取消</button>
                <button class="modal-btn confirm" onclick="executeClear()">确认清空</button>
            </div>
        </div>
    </div>

    <div id="info-modal">
        <div class="modal-box">
            <div class="modal-title">Spark Canvas</div>
            <div class="info-list">
                <div class="info-item"><i class="info-icon ri-computer-line"></i> <span>图片/文字上 <b>右键</b> 唤起菜单</span></div>
                <div class="info-item"><i class="info-icon ri-smartphone-line"></i> <span>图片/文字上 <b>长按</b> 唤起菜单</span></div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn primary" onclick="closeInfoModal()">知道了</button>
            </div>
            <div class="modal-footer">
                <div class="social-links">
                    <a href="#" class="social-icon" title="小红书"><i class="ri-book-2-fill"></i></a> 
                    <a href="#" class="social-icon" title="Weibo"><i class="ri-weibo-fill"></i></a>
                    <a href="#" class="social-icon" title="X"><i class="ri-twitter-x-fill"></i></a>
                    <a href="#" class="social-icon" title="Instagram"><i class="ri-instagram-fill"></i></a>
                </div>
                <div class="made-with">Made with <i class="ri-heart-fill"></i></div>
            </div>
        </div>
    </div>

    <div id="context-menu" class="glass-panel">
        <div class="menu-header show-header">图层 Layer</div>
        <div class="layer-controls">
            <div class="layer-btn" onclick="menuAction('top')"><i class="ri-arrow-up-double-line"></i></div>
            <div class="layer-btn" onclick="menuAction('up')"><i class="ri-arrow-up-s-line"></i></div>
            <div class="layer-btn" onclick="menuAction('down')"><i class="ri-arrow-down-s-line"></i></div>
            <div class="layer-btn" onclick="menuAction('bottom')"><i class="ri-arrow-down-double-line"></i></div>
        </div>
        
        <div class="menu-item show-always" id="menu-lock" onclick="menuAction('lock-toggle')">
            <i class="menu-icon-span ri-lock-line"></i> <span id="menu-lock-text">锁定</span>
        </div>

        <div class="menu-header image-menu-item">效果 Effect</div>
        <div class="menu-item image-menu-item" onclick="menuAction('flipX')"><i class="menu-icon-span ri-arrow-left-right-line"></i> 水平翻转</div>
        <div class="menu-item image-menu-item" onclick="menuAction('shadow')"><i class="menu-icon-span ri-drop-line"></i> 投影</div>

        <div class="menu-item image-menu-item" onclick="toggleFilterList()">
            <i class="menu-icon-span ri-contrast-drop-line"></i> 滤镜 Filter <i class="ri-arrow-right-s-line" id="filter-arrow-icon" style="margin-left:auto"></i>
        </div>

        <div id="filter-options-wrapper" class="popup-options-list glass-panel">
            <div class="popup-option" onclick="applyFilter('bw')">黑白 B&W</div>
            <div class="popup-option" onclick="applyFilter('cyber')">赛博 Cyber</div>
            <div class="popup-option" onclick="applyFilter('sunset')">落日 Sunset</div>
            <div class="popup-option" onclick="applyFilter('violet')">紫罗兰 Violet</div>
            <div class="popup-option" onclick="applyFilter('none')">无 None</div>
        </div>

        <div class="menu-header text-menu-item">文字设置</div>
        
        <div class="font-selector-row text-menu-item">
            <div class="font-toggle-btn" onclick="toggleFontList()">
                <span>字体 Font</span> <i class="ri-arrow-right-s-line" id="font-arrow-icon"></i>
            </div>
        </div>
        
        <div id="font-options-wrapper" class="popup-options-list glass-panel">
            <div class="popup-option" style="font-family: 'Noto Sans SC', sans-serif" onclick="changeFont('\'Noto Sans SC\', sans-serif')">思源黑体</div>
            <div class="popup-option" style="font-family: 'Noto Serif SC', serif" onclick="changeFont('\'Noto Serif SC\', serif')">思源宋体</div>
            <div class="popup-option" style="font-family: 'Outfit', sans-serif" onclick="changeFont('\'Outfit\', sans-serif')">Outfit</div>
        </div>

        <div class="text-colors-container text-menu-item">
            <div class="text-color-dot" style="background: #000000" onclick="changeTextColor('#000000')"></div>
            <div class="text-color-dot" style="background: #ffffff" onclick="changeTextColor('#ffffff')"></div>
            <div class="text-color-dot" style="background: #FFCC00" onclick="changeTextColor('#FFCC00')"></div>
            <div class="text-color-dot" style="background: #34C759" onclick="changeTextColor('#34C759')"></div>
            <div class="text-color-dot" style="background: #007AFF" onclick="changeTextColor('#007AFF')"></div>
            <div class="text-color-dot" style="background: #FF3B30" onclick="changeTextColor('#FF3B30')"></div>
        </div>
        
        <div class="align-toolbar text-menu-item">
            <div class="align-btn" onclick="menuAction('align-left')"><i class="ri-align-left"></i></div>
            <div class="align-btn" onclick="menuAction('align-center')"><i class="ri-align-center"></i></div>
            <div class="align-btn" onclick="menuAction('align-right')"><i class="ri-align-right"></i></div>
        </div>

        <div class="control-row text-menu-item">
            <span class="control-label">字重 Weight</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('weight-up')"><i class="ri-add-line"></i></div>
                <div class="control-btn" onclick="menuAction('weight-down')"><i class="ri-subtract-line"></i></div>
            </div>
        </div>
        <div class="control-row text-menu-item">
            <span class="control-label">字距 Spacing</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('spacing-up')"><i class="ri-add-line"></i></div>
                <div class="control-btn" onclick="menuAction('spacing-down')"><i class="ri-subtract-line"></i></div>
            </div>
        </div>
        <div class="control-row text-menu-item">
            <span class="control-label">行高 Height</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('line-height-up')"><i class="ri-add-line"></i></div>
                <div class="control-btn" onclick="menuAction('line-height-down')"><i class="ri-subtract-line"></i></div>
            </div>
        </div>

        <div class="menu-item show-always" onclick="menuAction('duplicate')"><i class="menu-icon-span ri-file-copy-line"></i> 复制</div>
        <div class="menu-item delete show-always" onclick="menuAction('delete')"><i class="menu-icon-span ri-delete-bin-line"></i> 删除</div>
    </div>
    
    <input type="file" id="file-input" accept="image/*" multiple onchange="handleFiles(this.files)">
    <input type="file" id="bg-file-input" accept="image/*" onchange="handleBgFile(this.files)">

    <script>
        // V2.10 启动页控制
        const appStartTime = Date.now();
        const SPLASH_MIN_DURATION = 1600; 
        let splashHidden = false; 

        function hideSplashScreen() {
            const splash = document.getElementById('splash-screen');
            if (!splash || splash.style.display === 'none') {
                splashHidden = true;
                return;
            }
            if (splashHidden) return;
            splashHidden = true;

            const now = Date.now();
            const elapsed = now - appStartTime;
            const remaining = Math.max(0, SPLASH_MIN_DURATION - elapsed);

            setTimeout(() => {
                splash.classList.add('hidden');
                setTimeout(() => {
                    splash.style.display = 'none';
                }, 600); 
            }, remaining);
        }
        
        setTimeout(hideSplashScreen, 3000);

        const SCREEN_WIDTH = 540;
        const SCREEN_HEIGHT = 960;
        let screenCount = 1;
        fabric.textureSize = 2048; 

        // 布局缓存
        let layoutState = { visualHeight: 0, availableHeight: 0 };

        const rotateIconImg = new Image();
        rotateIconImg.src = 'rotate.png';
        rotateIconImg.onload = function() { if(canvas) canvas.requestRenderAll(); }

        function renderCustomIcon(ctx, left, top, styleOverride, fabricObject) {
            const size = 20; 
            ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            ctx.beginPath(); ctx.arc(0, 0, size/2, 0, 2 * Math.PI); ctx.fillStyle = "#007AFF"; ctx.fill();
            ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 3; ctx.shadowOffsetY = 1;
            const iconSize = size * 0.7; 
            if (rotateIconImg.complete && rotateIconImg.naturalWidth !== 0) {
                 ctx.drawImage(rotateIconImg, -iconSize/2, -iconSize/2, iconSize, iconSize);
            } else {
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(0,0, 3, 0, 2*Math.PI); ctx.fill();
            }
            ctx.restore();
        }

        fabric.Object.prototype.set({
            snapAngle: 90, snapThreshold: 3,
            cornerStyle: 'circle', cornerColor: '#007AFF', borderColor: '#007AFF',
            transparentCorners: false, borderScaleFactor: 2, cornerSize: 10,
            centeredScaling: false, lockUniScaling: true,
            lockMovementX: false, lockMovementY: false
        });

        fabric.Object.prototype.controls.mtr = new fabric.Control({
            x: 0, y: -0.5, offsetY: -25, 
            actionHandler: fabric.controlsUtils.rotationWithSnapping,
            cursorStyle: 'crosshair', render: renderCustomIcon, actionName: 'rotate'
        });

        const canvas = new fabric.Canvas('c', {
            width: window.innerWidth, height: window.innerHeight,
            backgroundColor: null, 
            preserveObjectStacking: true, 
            fireRightClick: true, stopContextMenu: true,
            selection: true, // V3.4 核心修复: 默认开启选择功能
            allowTouchScrolling: false,
            targetFindTolerance: 20 
        });

        // V3.6 核心修复: 直接在原型上修改 ActiveSelection 的默认配置
        fabric.ActiveSelection.prototype.setControlsVisibility({
            mt: false, // 隐藏上中
            mb: false, // 隐藏下中
            ml: false, // 隐藏左中
            mr: false  // 隐藏右中
        });

        // V3.7 核心: 虚拟 Shift 键逻辑
        let isVirtualShiftPressed = false;
        const virtualShiftBtn = document.getElementById('virtual-shift-btn');

        // V1.4 重写: 辅助判定
        const originalIsSelectionKeyPressed = fabric.Canvas.prototype._isSelectionKeyPressed;
        fabric.Canvas.prototype._isSelectionKeyPressed = function(e) {
            return isVirtualShiftPressed || (e && e.shiftKey);
        };

        // 使用 touchstart/end 响应更即时
        virtualShiftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            isVirtualShiftPressed = true;
            virtualShiftBtn.classList.add('active');
            canvas.selection = true; 
        }, { passive: false });

        virtualShiftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            isVirtualShiftPressed = false;
            virtualShiftBtn.classList.remove('active');
        }, { passive: false });
        
        // 兼容鼠标操作
        virtualShiftBtn.addEventListener('mousedown', () => {
            isVirtualShiftPressed = true;
            virtualShiftBtn.classList.add('active');
            canvas.selection = true;
        });
        virtualShiftBtn.addEventListener('mouseup', () => {
            isVirtualShiftPressed = false;
            virtualShiftBtn.classList.remove('active');
        });

        let gridLines = [];
        const contextMenu = document.getElementById('context-menu');
        const bgPanel = document.getElementById('bg-panel');
        const statusIndicator = document.getElementById('status-indicator');
        const confirmModal = document.getElementById('confirm-modal');
        const infoModal = document.getElementById('info-modal');
        const sideBar = document.querySelector('.side-bar');
        const sideBarBottom = document.querySelector('.side-bar-bottom');

        const DB_NAME = "SparkCanvasDB"; const STORE_NAME = "sessions";
        let db; let saveTimeout;

        let isInternalUpdate = false;
        let currentBgFill = '#ffffff'; 
        let bgRect; 

        // --- V1.6 最终绝杀: 强行状态托管 ---
        let selectionBeforeClick = [];

        // 1. 在点击发生前，把当前的名单强行克隆一份（浅拷贝数组，防止引用丢失）
        canvas.on('mouse:down:before', function(opt) {
            const evt = opt.e;
            const isShift = isVirtualShiftPressed || (evt && evt.shiftKey);
            if (isShift) {
                // 关键点: [...array] 强制复制，切断引用联系
                selectionBeforeClick = [...canvas.getActiveObjects()];
            }
        });

        function updateWorkspace() {
            isInternalUpdate = true;
            if (bgRect && canvas.contains(bgRect)) canvas.remove(bgRect);
            
            bgRect = new fabric.Rect({
                left: 0, top: 0,
                width: screenCount * SCREEN_WIDTH,
                height: SCREEN_HEIGHT,
                fill: currentBgFill,
                selectable: false, evented: false, 
                isBackground: true 
            });
            canvas.add(bgRect);
            canvas.sendToBack(bgRect);

            canvas.clipPath = new fabric.Rect({
                left: 0, top: 0,
                width: screenCount * SCREEN_WIDTH,
                height: SCREEN_HEIGHT,
                absolutePositioned: false 
            });

            gridLines.forEach(l => canvas.remove(l)); 
            gridLines = [];
            for (let i = 1; i < screenCount; i++) {
                const line = new fabric.Line([i * SCREEN_WIDTH, 0, i * SCREEN_WIDTH, SCREEN_HEIGHT], {
                    stroke: '#007AFF', strokeWidth: 1, strokeDashArray: [5, 5], opacity: 0.3, selectable: false, evented: false, excludeFromExport: true
                });
                canvas.add(line); gridLines.push(line);
            }
            isInternalUpdate = false;
        }

        function updateSideBarPosition() {
            const vpt = canvas.viewportTransform;
            if(!vpt) return;
            const zoom = canvas.getZoom();
            
            const contentRightEdge = vpt[4] + (screenCount * SCREEN_WIDTH * zoom);
            const contentBottomEdge = vpt[5] + (SCREEN_HEIGHT * zoom);
            const newLeft = (contentRightEdge + 12) + 'px'; 
            
            sideBar.style.left = newLeft; 
            
            if(sideBarBottom) {
                sideBarBottom.style.left = newLeft;
                sideBarBottom.style.top = (contentBottomEdge - 93) + 'px'; 
            }
        }

        function focusOnPage(index) {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const zoom = canvas.getZoom();
            
            const availableSpaceTop = 0;
            const availableSpaceBottom = winH - 100; 
            const visualSpaceCenterY = (availableSpaceTop + availableSpaceBottom) / 2;
            
            const contentHalfHeight = (SCREEN_HEIGHT * zoom) / 2;
            const targetY = visualSpaceCenterY - contentHalfHeight + 10;

            const vpt = canvas.viewportTransform;
            vpt[4] = (winW / 2) - ((index * SCREEN_WIDTH + SCREEN_WIDTH / 2) * zoom);
            vpt[5] = targetY;

            canvas.requestRenderAll();
            updateSideBarPosition();
        }

        function initViewport() {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            
            canvas.setWidth(winW);
            canvas.setHeight(winH);
            
            const safeW = winW - 40; 
            const safeH = winH - 220; 
            
            const scaleX = safeW / SCREEN_WIDTH;
            const scaleY = safeH / SCREEN_HEIGHT;
            let zoom = Math.min(scaleX, scaleY);
            
            if (zoom > 1) zoom = 1; 
            if (zoom < 0.1) zoom = 0.1;
            canvas.setZoom(zoom);

            layoutState.visualHeight = SCREEN_HEIGHT * zoom;
            layoutState.availableHeight = winH - 140; 

            focusOnPage(0);
            updateHitRegions(); 
        }
        
        function updateHitRegions() {
            canvas.forEachObject(obj => obj.setCoords());
        }

        window.addEventListener('resize', () => {
            initViewport(); 
        });

        setTimeout(() => {
            updateWorkspace();
            initViewport();
        }, 100);

        let isDraggingCanvas = false;
        let lastX, lastY;
        let mouseDownPoint = {x:0, y:0};
        let mouseDownTarget = null; 

        let velocityX = 0, velocityY = 0;
        let lastMoveTime = 0;
        let momentumID = null;

        function getClientPos(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function getBroadType(type) {
            if (type === 'i-text' || type === 'text' || type === 'textbox') return 'text';
            if (type === 'image') return 'image';
            return 'other';
        }

        function updateContextMenuState(target) {
            const lockItemText = document.getElementById('menu-lock-text');
            const lockIcon = document.querySelector('#menu-lock .menu-icon-span');
            
            let isLocked = target.lockMovementX;

            if (target.type === 'activeSelection' && target._objects && target._objects.length > 0) {
                isLocked = target._objects[0].lockMovementX;
            }
            
            if (isLocked) {
                lockItemText.innerText = "解锁";
                lockIcon.className = "menu-icon-span ri-lock-unlock-line"; 
            } else {
                lockItemText.innerText = "锁定";
                lockIcon.className = "menu-icon-span ri-lock-line"; 
            }
        }

        function getCanvasBounds() {
            const winW = window.innerWidth;
            const zoom = canvas.getZoom();
            const maxLeft = (winW / 2) - (SCREEN_WIDTH * zoom / 2);
            const minLeft = (winW / 2) - ((screenCount * SCREEN_WIDTH - SCREEN_WIDTH/2) * zoom);
            return { min: minLeft, max: maxLeft };
        }

        function snapBack() {
            const bounds = getCanvasBounds();
            const currentX = canvas.viewportTransform[4];
            let targetX = currentX;

            if (currentX > bounds.max) targetX = bounds.max;
            else if (currentX < bounds.min) targetX = bounds.min;
            else return; 

            fabric.util.animate({
                startValue: currentX,
                endValue: targetX,
                duration: 400,
                easing: fabric.util.ease.easeOutQuart,
                onChange: function(value) {
                    canvas.viewportTransform[4] = value;
                    canvas.requestRenderAll();
                    updateSideBarPosition();
                },
                onComplete: function() {
                      canvas.setViewportTransform(canvas.viewportTransform);
                      updateHitRegions();
                }
            });
        }

        // --- V1.6 重写后的 mouse:down 逻辑 ---
        canvas.on('mouse:down', function(opt) {
            const evt = opt.e;
            const target = opt.target;

            // 检测 Shift 状态
            const isShiftActive = evt.shiftKey || isVirtualShiftPressed;

            if (isShiftActive) {
                isDraggingCanvas = false; 
                canvas.selection = true; 

                // --- V1.6 核心: 手动管理 Toggle 逻辑 ---
                if (target && target !== bgRect) {
                    // 获取刚才存下的"旧名单" (确保是数组)
                    const existingObjects = selectionBeforeClick || [];
                    
                    // 检查当前点击的目标在不在旧名单里
                    const index = existingObjects.indexOf(target);
                    
                    let newSelectionList;
                    
                    if (index > -1) {
                        // 如果已经在名单里 -> 踢出去 (反选)
                        newSelectionList = existingObjects.filter(o => o !== target);
                    } else {
                        // 如果不在名单里 -> 加进去 (增选)
                        newSelectionList = [...existingObjects, target];
                    }

                    // 强制更新选区
                    if (newSelectionList.length > 0) {
                        // 建立新的选区组
                        const activeSel = new fabric.ActiveSelection(newSelectionList, { canvas: canvas });
                        canvas.setActiveObject(activeSel);
                    } else {
                        // 如果空了，就清空
                        canvas.discardActiveObject();
                    }
                    canvas.requestRenderAll();
                }
                // -------------------------------------
                return; // 直接结束，不让 Fabric 默认逻辑干扰
            }

            // --- 以下是原有的非 Shift 逻辑 (保持不变) ---
            cancelAnimationFrame(momentumID);
            velocityX = 0; velocityY = 0;
            lastMoveTime = Date.now();
            
            if (opt.button === 3) {
                if (target && target !== bgRect) {
                    canvas.setActiveObject(target);
                    openContextMenu(opt);
                }
                return;
            }

            const pos = getClientPos(evt);
            lastX = pos.x; lastY = pos.y;
            mouseDownPoint = { x: pos.x, y: pos.y };

            if (!target || target === bgRect) {
                contextMenu.style.display = 'none';
                document.getElementById('font-options-wrapper').classList.remove('active');
                document.getElementById('filter-options-wrapper').classList.remove('active');
                
                canvas.selection = false; 
                isDraggingCanvas = true;
                mouseDownTarget = null;
            } else {
                isDraggingCanvas = false;
                
                const currentType = getBroadType(target.type);
                const menuType = contextMenu.dataset.currentType; 
                if (currentType !== menuType && contextMenu.style.display === 'block') {
                    contextMenu.style.display = 'none';
                }
                
                if (target.lockMovementX) {
                    isDraggingCanvas = true;
                    mouseDownTarget = target; 
                    canvas.discardActiveObject(); 
                    canvas.requestRenderAll();
                }
            }
            
            if (bgPanel.style.display === 'block') bgPanel.style.display = 'none';
            
            if (target && target !== bgRect && evt.type === 'touchstart') {
                if (target.__corner) return;
                longPressTimer = setTimeout(() => {
                    const active = canvas.getActiveObject();
                    if (isDraggingCanvas && Math.abs(lastX - pos.x) < 5 && Math.abs(lastY - pos.y) < 5) {
                        isDraggingCanvas = false; 
                        canvas.setActiveObject(target); 
                        openContextMenu(opt);
                    } else if (!isDraggingCanvas && active && !active.isMoving && !active.isScaling && !active.isRotating) {
                        openContextMenu(opt);
                    }
                }, 500);
            }
        });

        let isObjectMoving = false;
        canvas.on('mouse:move', function(opt) {
            if (isDraggingCanvas) {
                const evt = opt.e;
                const pos = getClientPos(evt);
                if (pos.x === undefined || pos.y === undefined) return;
                
                const now = Date.now();
                const dt = now - lastMoveTime;

                let deltaX = pos.x - lastX;
                let deltaY = pos.y - lastY;

                if (dt > 0) {
                    const newVx = deltaX / dt;
                    const newVy = deltaY / dt;
                    velocityX = velocityX * 0.5 + newVx * 0.5;
                    velocityY = velocityY * 0.5 + newVy * 0.5;
                    lastMoveTime = now;
                }

                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    clearTimeout(longPressTimer);
                }

                if (layoutState.visualHeight <= layoutState.availableHeight) {
                    deltaY = 0; 
                    velocityY = 0; 
                }

                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                const proposedX = currentX + deltaX;

                if (proposedX > bounds.max) {
                      const overage = proposedX - bounds.max;
                      const resistance = 1 / (1 + Math.abs(overage) * 0.003); 
                      deltaX *= resistance;
                } else if (proposedX < bounds.min) {
                      const overage = bounds.min - proposedX;
                      const resistance = 1 / (1 + Math.abs(overage) * 0.003);
                      deltaX *= resistance;
                }

                canvas.relativePan({ x: deltaX, y: deltaY });
                updateSideBarPosition();
                
                lastX = pos.x;
                lastY = pos.y;
            } else {
                const active = canvas.getActiveObject();
                if (active && (active.isMoving || active.isScaling || active.isRotating)) {
                    isObjectMoving = true;
                    clearTimeout(longPressTimer);
                }
            }
        });

        canvas.on('mouse:up', function(opt) {
            canvas.selection = true;

            const evt = opt.e;
            const pos = getClientPos(evt);
            
            if (isDraggingCanvas && mouseDownTarget && mouseDownTarget.lockMovementX) {
                const dist = Math.sqrt(Math.pow(pos.x - mouseDownPoint.x, 2) + Math.pow(pos.y - mouseDownPoint.y, 2));
                if (dist < 5) { 
                    canvas.setActiveObject(mouseDownTarget);
                    canvas.requestRenderAll();
                }
            }

            if (isDraggingCanvas) {
                const timeSinceLastMove = Date.now() - lastMoveTime;
                if (timeSinceLastMove > 100) {
                    velocityX = 0;
                    velocityY = 0;
                }
                
                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                
                if (currentX > bounds.max || currentX < bounds.min) {
                    velocityX = 0; velocityY = 0;
                    snapBack();
                } else {
                    applyMomentum();
                }
            }

            isDraggingCanvas = false;
            isObjectMoving = false;
            clearTimeout(longPressTimer);
            canvas.setViewportTransform(canvas.viewportTransform); 
            updateSideBarPosition();
            updateHitRegions(); 
        });

        function applyMomentum() {
            const friction = 0.95; 
            const stopThreshold = 0.01;

            function step() {
                if (Math.abs(velocityX) < stopThreshold && Math.abs(velocityY) < stopThreshold) {
                    cancelAnimationFrame(momentumID);
                    return;
                }

                velocityX *= friction;
                velocityY *= friction;

                let panX = velocityX * 16; 
                let panY = velocityY * 16;

                if (layoutState.visualHeight <= layoutState.availableHeight) {
                    panY = 0;
                }

                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                const proposedX = currentX + panX;

                if (proposedX > bounds.max || proposedX < bounds.min) {
                    cancelAnimationFrame(momentumID);
                    snapBack();
                    return;
                }

                canvas.relativePan({ x: panX, y: panY });
                updateSideBarPosition();
                
                momentumID = requestAnimationFrame(step);
            }
            step();
        }

        canvas.on('mouse:wheel', function(opt) {
            opt.e.preventDefault();
            opt.e.stopPropagation();
        });

        let initialDistance = 0;
        let initialZoom = 1;
        let initialObjectScale = 1;
        let activeObjectForPinch = null;
        let pinchMode = null; 

        canvas.upperCanvasEl.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                isDraggingCanvas = false; 
                const pointer0 = canvas.getPointer(e.touches[0]); 
                let target = canvas.findTarget(e); 
                if (target === bgRect) target = null;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                if (target && target === canvas.getActiveObject()) {
                    pinchMode = 'object';
                    initialObjectScale = target.scaleX;
                } else {
                    pinchMode = null; 
                }
                e.preventDefault();
            }
        }, { passive: false });

        canvas.upperCanvasEl.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && initialDistance > 0) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                
                if (pinchMode === 'object') {
                    const target = canvas.getActiveObject();
                    if(target) {
                        const scaleFactor = currentDistance / initialDistance;
                        let newScale = initialObjectScale * scaleFactor;
                        if(newScale < 0.1) newScale = 0.1;
                        target.scale(newScale);
                        target.setCoords();
                        canvas.requestRenderAll();
                    }
                }
            }
        }, { passive: false });
        
        canvas.upperCanvasEl.addEventListener('touchend', function(e) {
            if(e.touches.length < 2) {
                initialDistance = 0;
                pinchMode = null;
                updateHitRegions(); 
            }
        });

        let longPressTimer;
        const FONT_WEIGHTS = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        function menuAction(action) {
            const obj = canvas.getActiveObject(); if (!obj) return;
            switch(action) {
                case 'lock-toggle':
                    const toggleLock = (targetObj, shouldLock) => {
                        if (shouldLock) {
                            targetObj.set({
                                lockMovementX: true, lockMovementY: true,
                                lockRotation: true, lockScalingX: true, lockScalingY: true,
                                hasControls: false, borderColor: '#ff453a'
                            });
                        } else {
                            targetObj.set({
                                lockMovementX: false, lockMovementY: false,
                                lockRotation: false, lockScalingX: false, lockScalingY: false,
                                hasControls: true, borderColor: '#007AFF'
                            });
                        }
                    };

                    let nextState = true; 
                    
                    if (obj.type === 'activeSelection') {
                        if (obj._objects.length > 0 && obj._objects[0].lockMovementX) {
                            nextState = false;
                        }
                        obj.forEachObject(subObj => toggleLock(subObj, nextState));
                        toggleLock(obj, nextState); 
                        
                    } else {
                        if (obj.lockMovementX) nextState = false;
                        toggleLock(obj, nextState);
                    }

                    canvas.requestRenderAll();
                    triggerAutoSave();
                    updateContextMenuState(obj); 
                    break;

                case 'top': obj.bringToFront(); break; case 'bottom': obj.sendToBack(); break;
                case 'up': obj.bringForward(); break; case 'down': obj.sendBackwards(); break;
                
                case 'delete': 
                    if (obj.type === 'activeSelection') {
                        obj.forEachObject(subObj => canvas.remove(subObj));
                        canvas.discardActiveObject();
                    } else {
                        canvas.remove(obj); 
                        canvas.discardActiveObject(); 
                    }
                    break;

                case 'duplicate':
                    obj.clone(function(cloned) {
                        canvas.discardActiveObject();
                        cloned.set({ left: obj.left + 20, top: obj.top + 20, evented: true });
                        if(cloned.type === 'i-text' || cloned.type === 'text') cloned.set('objectCaching', false);
                        if (cloned.type === 'activeSelection') {
                            cloned.canvas = canvas;
                            cloned.forEachObject(function(o) { canvas.add(o); });
                            cloned.setCoords();
                        } else { canvas.add(cloned); }
                        canvas.setActiveObject(cloned);
                        canvas.requestRenderAll();
                        triggerAutoSave();
                    });
                    break;
                case 'flipX': if(obj.type === 'image') obj.set('flipX', !obj.flipX); break;
                case 'shadow': if (obj.type === 'image') { if (obj.shadow) { obj.set('shadow', null); } else { obj.set('shadow', new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 20, offsetX: 10, offsetY: 10 })); } } break;
                case 'spacing-up': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.charSpacing || 0; obj.set('charSpacing', val + 50); } break;
                case 'spacing-down': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.charSpacing || 0; obj.set('charSpacing', val - 50); } break;
                case 'line-height-up': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.lineHeight || 1.16; obj.set('lineHeight', val + 0.1); } break;
                case 'line-height-down': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.lineHeight || 1.16; if(val > 0.5) obj.set('lineHeight', val - 0.1); } break;
                case 'align-left': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'left'); break;
                case 'align-center': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'center'); break;
                case 'align-right': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'right'); break;
                case 'weight-up': if (obj.type === 'i-text' || obj.type === 'text') { let current = parseInt(obj.fontWeight) || 600; if(current === 'normal') current = 400; if(current === 'bold') current = 700; let next = FONT_WEIGHTS.find(w => w > current); if (!next) next = FONT_WEIGHTS[FONT_WEIGHTS.length - 1]; obj.set('fontWeight', next); } break;
                case 'weight-down': if (obj.type === 'i-text' || obj.type === 'text') { let current = parseInt(obj.fontWeight) || 600; if(current === 'normal') current = 400; if(current === 'bold') current = 700; let prev = [...FONT_WEIGHTS].reverse().find(w => w < current); if (!prev) prev = FONT_WEIGHTS[0]; obj.set('fontWeight', prev); } break;
            }
            if(bgRect) canvas.sendToBack(bgRect);
            bringGridToFront(); canvas.renderAll(); triggerAutoSave();
            
            const keepOpen = [
                'weight-up', 'weight-down', 
                'spacing-up', 'spacing-down', 
                'line-height-up', 'line-height-down', 
                'align-left', 'align-center', 'align-right',
                'top', 'bottom', 'up', 'down',
                'lock-toggle' 
            ];
            
            if (!keepOpen.includes(action)) {
                contextMenu.style.display = 'none';
                document.getElementById('font-options-wrapper').classList.remove('active');
                document.getElementById('font-arrow-icon').className = "ri-arrow-right-s-line";
                document.getElementById('filter-options-wrapper').classList.remove('active');
                if(document.getElementById('filter-arrow-icon')) document.getElementById('filter-arrow-icon').className = "ri-arrow-right-s-line";
            }
        }

        function openContextMenu(opt) {
            const target = opt.target || canvas.getActiveObject();
            if(!target || target === bgRect) return;
            
            canvas.setActiveObject(target);
            const type = target.type;
            const imageItems = document.querySelectorAll('.image-menu-item');
            const textItems = document.querySelectorAll('.text-menu-item');
            const layerControls = document.querySelector('.layer-controls'); 

            if (type === 'activeSelection') {
                layerControls.style.display = 'none';
            } else {
                layerControls.style.display = 'flex';
            }

            contextMenu.dataset.currentType = getBroadType(type);
            updateContextMenuState(target);

            document.getElementById('font-options-wrapper').classList.remove('active');
            document.getElementById('font-arrow-icon').className = "ri-arrow-right-s-line";
            document.getElementById('filter-options-wrapper').classList.remove('active');
            if(document.getElementById('filter-arrow-icon')) document.getElementById('filter-arrow-icon').className = "ri-arrow-right-s-line";

            if (type === 'image') {
                imageItems.forEach(el => el.style.display = 'flex');
                textItems.forEach(el => el.style.display = 'none');
            } else if (type === 'i-text' || type === 'text') {
                imageItems.forEach(el => el.style.display = 'none');
                textItems.forEach(el => el.style.display = 'flex'); 
            } else {
                imageItems.forEach(el => el.style.display = 'none');
                textItems.forEach(el => el.style.display = 'none');
            }

            let clientX, clientY;
            if (opt.e.changedTouches && opt.e.changedTouches[0]) {
                clientX = opt.e.changedTouches[0].clientX;
                clientY = opt.e.changedTouches[0].clientY;
            } else {
                clientX = opt.e.clientX;
                clientY = opt.e.clientY;
            }

            contextMenu.style.display = 'block';
            const menuW = contextMenu.offsetWidth;
            const menuH = contextMenu.offsetHeight;

            let left = clientX + 10;
            let top = clientY - (menuH / 2);

            if (left + menuW > window.innerWidth) left = clientX - menuW - 10;
            if (top + menuH > window.innerHeight) top = window.innerHeight - menuH - 10;
            if (top < 10) top = 10;

            contextMenu.style.left = left + 'px';
            contextMenu.style.top = top + 'px';
            bgPanel.style.display = 'none';
        }

        function toggleFontList() {
            const list = document.getElementById('font-options-wrapper');
            const arrow = document.getElementById('font-arrow-icon');
            list.classList.toggle('active');
            document.getElementById('filter-options-wrapper').classList.remove('active');
            
            if(list.classList.contains('active')) {
                arrow.className = "ri-arrow-left-s-line";
            } else {
                arrow.className = "ri-arrow-right-s-line";
            }
        }

        function toggleFilterList() {
            const list = document.getElementById('filter-options-wrapper');
            const arrow = document.getElementById('filter-arrow-icon');
            list.classList.toggle('active');
            document.getElementById('font-options-wrapper').classList.remove('active');

            if(list.classList.contains('active')) {
                arrow.className = "ri-arrow-left-s-line";
            } else {
                arrow.className = "ri-arrow-right-s-line";
            }
        }
        
        function applyFilter(type) {
            const activeObj = canvas.getActiveObject();
            if (!activeObj || activeObj.type !== 'image') return;

            activeObj.filters = []; 

            switch (type) {
                case 'bw':
                    activeObj.filters.push(new fabric.Image.filters.Grayscale());
                    break;
                case 'cyber':
                    activeObj.filters.push(new fabric.Image.filters.Composed({
                        subFilters: [
                            new fabric.Image.filters.Grayscale({ mode: 'luminosity' }),
                            new fabric.Image.filters.BlendColor({ color: '#76ff03', mode: 'multiply' }),
                            new fabric.Image.filters.BlendColor({ color: '#2962ff', mode: 'lighten' })
                        ]
                    }));
                    break;
                case 'sunset':
                    activeObj.filters.push(new fabric.Image.filters.Composed({
                        subFilters: [
                            new fabric.Image.filters.Grayscale({ mode: 'luminosity' }),
                            new fabric.Image.filters.BlendColor({ color: '#ffd600', mode: 'multiply' }),
                            new fabric.Image.filters.BlendColor({ color: '#d50000', mode: 'lighten' })
                        ]
                    }));
                    break;
                case 'violet':
                    activeObj.filters.push(new fabric.Image.filters.Composed({
                        subFilters: [
                            new fabric.Image.filters.Grayscale({ mode: 'luminosity' }),
                            new fabric.Image.filters.BlendColor({ color: '#e040fb', mode: 'multiply' }),
                            new fabric.Image.filters.BlendColor({ color: '#4a148c', mode: 'lighten' })
                        ]
                    }));
                    break;
                case 'none':
                    break;
            }

            activeObj.applyFilters();
            canvas.requestRenderAll();
            triggerAutoSave();
            toggleFilterList(); 
        }

        function addDefaultText() {
            const text = new fabric.IText('SparkCanvas', {
                left: SCREEN_WIDTH / 2, 
                top: SCREEN_HEIGHT / 2,
                fontFamily: "'Outfit', sans-serif", 
                fontWeight: 600, 
                fill: '#000000', 
                fontSize: 40,
                originX: 'center', 
                originY: 'center',
                textAlign: 'left',
                charSpacing: 0,
                shadow: null,
                objectCaching: false 
            });
            text.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
            canvas.add(text);
            canvas.requestRenderAll();
        }

        function resizeImage(dataUrl, callback) {
            const img = new Image();
            img.onload = () => {
                const maxDim = 2048; 
                let width = img.width;
                let height = img.height;

                if (width > maxDim || height > maxDim) {
                    if (width > height) {
                        height *= maxDim / width;
                        width = maxDim;
                    } else {
                        width *= maxDim / height;
                        height = maxDim;
                    }
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    callback(tempCanvas.toDataURL('image/jpeg', 0.9)); 
                } else {
                    callback(dataUrl);
                }
            };
            img.src = dataUrl;
        }

        function showModal() { confirmModal.style.display = 'block'; }
        function closeModal() { confirmModal.style.display = 'none'; }
        
        function showInfoModal() { infoModal.style.display = 'block'; }
        function closeInfoModal() { infoModal.style.display = 'none'; }

        function executeClear() {
            canvas.clear(); 
            bgRect = null;
            gridLines = [];
            screenCount = 1; 
            currentBgFill = '#ffffff'; 
            updateWorkspace();
            addDefaultText();
            initViewport();
            if(db) { const tx = db.transaction(STORE_NAME, "readwrite"); tx.objectStore(STORE_NAME).delete("last_session"); }
            closeModal();
        }

        function changeFont(fontFamily) {
            const activeObj = canvas.getActiveObject();
            if (activeObj && (activeObj.type === 'i-text' || activeObj.type === 'text')) {
                activeObj.set("fontFamily", fontFamily);
                activeObj.set("fontWeight", 600);
                canvas.requestRenderAll();
                triggerAutoSave();
                toggleFontList();
            }
        }

        function changeTextColor(color) {
            const activeObj = canvas.getActiveObject();
            if (activeObj && (activeObj.type === 'i-text' || activeObj.type === 'text')) {
                activeObj.set("fill", color);
                canvas.requestRenderAll();
                triggerAutoSave();
            }
        }

        function addText() {
            const center = canvas.getVpCenter();
            const selectedFont = "'Outfit', sans-serif";
            const text = new fabric.IText('SparkCanvas', {
                left: center.x, top: center.y,
                fontFamily: selectedFont, 
                fontWeight: 600, 
                fill: '#000000', 
                fontSize: 40,
                originX: 'center', 
                originY: 'center',
                textAlign: 'left',
                charSpacing: 0,
                shadow: null,
                objectCaching: false 
            });
            text.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
            canvas.add(text);
            canvas.setActiveObject(text);
            triggerAutoSave();
        }

        function addScreen() { 
            screenCount++; 
            updateWorkspace(); 
            canvas.requestRenderAll(); 
            triggerAutoSave(); 
            focusOnPage(screenCount - 1);
        }
        function removeScreen() { 
            if (screenCount > 1) { 
                screenCount--; 
                updateWorkspace(); 
                canvas.requestRenderAll(); 
                triggerAutoSave(); 
                focusOnPage(screenCount - 1);
            } 
        }

        function toggleBgPanel() {
            const isVisible = bgPanel.style.display === 'block';
            bgPanel.style.display = isVisible ? 'none' : 'block';
        }

        function changeBackgroundColor(color) {
            currentBgFill = color;
            if(bgRect) {
                bgRect.set('fill', color);
                canvas.requestRenderAll();
                triggerAutoSave();
            }
        }

        function handleFiles(files) {
            if (!files || !files[0]) return;
            Array.from(files).forEach(file => processImageFile(file, false));
            document.getElementById('file-input').value = '';
        }

        function handleBgFile(files) {
            if (!files || !files[0]) return;
            processImageFile(files[0], true);
            document.getElementById('bg-file-input').value = '';
        }

        function applyPattern(imgSrc) {
            fabric.util.loadImage(imgSrc, function(img) {
                if(!img) return;
                const pattern = new fabric.Pattern({ source: img, repeat: 'repeat' });
                currentBgFill = pattern;
                if(bgRect) {
                    bgRect.set('fill', pattern);
                    canvas.requestRenderAll();
                    triggerAutoSave();
                }
            });
        }

        function processImageFile(file, isBackground = false) {
            const reader = new FileReader();
            reader.onload = (f) => {
                resizeImage(f.target.result, (resizedDataUrl) => {
                    if (isBackground) {
                        applyPattern(resizedDataUrl);
                    } else {
                        const center = canvas.getVpCenter();
                        fabric.Image.fromURL(resizedDataUrl, (img) => {
                            if (img.width > SCREEN_WIDTH) img.scaleToWidth(SCREEN_WIDTH * 0.8);
                            const offsetX = (Math.random() * 40 - 20);
                            const offsetY = (Math.random() * 40 - 20);
                            img.set({ left: center.x - (img.getScaledWidth()/2) + offsetX, top: center.y - (img.getScaledHeight()/2) + offsetY });
                            img.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                            canvas.add(img); 
                            canvas.setActiveObject(img); 
                            bringGridToFront(); 
                            triggerAutoSave();
                            canvas.requestRenderAll(); 
                        });
                    }
                });
            };
            reader.readAsDataURL(file);
        }

        let renderingLines = [];

        canvas.on('object:moving', function(e) {
            const obj = e.target;
            const threshold = 15; 
            renderingLines = []; 
            
            const objCenter = obj.getCenterPoint();
            let finalX = objCenter.x;
            let finalY = objCenter.y;
            
            const pageIndex = Math.floor((obj.left + obj.width * obj.scaleX / 2) / SCREEN_WIDTH);
            const screenCenterX = pageIndex * SCREEN_WIDTH + SCREEN_WIDTH / 2;
            const screenCenterY = SCREEN_HEIGHT / 2;

            let snappedX = false, snappedY = false;

            if (Math.abs(objCenter.x - screenCenterX) < threshold) {
                finalX = screenCenterX;
                renderingLines.push({x1: screenCenterX, y1: 0, x2: screenCenterX, y2: SCREEN_HEIGHT});
                snappedX = true;
            }
            if (Math.abs(objCenter.y - screenCenterY) < threshold) {
                finalY = screenCenterY;
                renderingLines.push({x1: pageIndex * SCREEN_WIDTH, y1: screenCenterY, x2: (pageIndex + 1) * SCREEN_WIDTH, y2: screenCenterY});
                snappedY = true;
            }

            if (!snappedX || !snappedY) {
                canvas.getObjects().forEach(target => {
                    if (target === obj || target === bgRect || target.excludeFromExport || !target.visible) return;
                    const tCenter = target.getCenterPoint();
                    if (!snappedX && Math.abs(objCenter.x - tCenter.x) < threshold) {
                        finalX = tCenter.x;
                        renderingLines.push({
                            x1: tCenter.x, 
                            y1: Math.min(obj.top, target.top)-50, 
                            x2: tCenter.x, 
                            y2: Math.max(obj.top+obj.height*obj.scaleY, target.top+target.height*target.scaleY)+50
                        });
                        snappedX = true;
                    }
                    if (!snappedY && Math.abs(objCenter.y - tCenter.y) < threshold) {
                        finalY = tCenter.y;
                        renderingLines.push({
                            x1: Math.min(obj.left, target.left)-50, 
                            y1: tCenter.y, 
                            x2: Math.max(obj.left+obj.width*obj.scaleX, target.left+target.width*target.scaleX)+50, 
                            y2: tCenter.y
                        });
                        snappedY = true;
                    }
                });
            }
            obj.setPositionByOrigin(new fabric.Point(finalX, finalY), 'center', 'center');
            canvas.requestRenderAll();
        });
        
        canvas.on('mouse:up', function() { 
            renderingLines = []; 
            canvas.requestRenderAll(); 
        });

        canvas.on('after:render', function(opt) {
            if(renderingLines.length === 0) return;
            const ctx = canvas.getContext();
            ctx.save();
            const vpt = canvas.viewportTransform;
            const retina = canvas.getRetinaScaling();
            ctx.setTransform(vpt[0] * retina, vpt[1] * retina, vpt[2] * retina, vpt[3] * retina, vpt[4] * retina, vpt[5] * retina);
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#ff0077';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            renderingLines.forEach(l => { ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); });
            ctx.stroke();
            ctx.restore();
        });

        function initDB() {
            try {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => { db = e.target.result; if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME); };
                request.onsuccess = (e) => { db = e.target.result; loadState(); };
            } catch(e) { console.log("DB Error", e); }
        }

        function saveState() {
            if (!db || isInternalUpdate) return;
            canvas.clipPath = null;
            const json = canvas.toJSON(['isBackground', 'lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'hasControls', 'borderColor']);
            updateWorkspace(); 
            const saveData = { id: "autosave", canvas: json, screenCount: screenCount, bgFill: currentBgFill, updated: new Date().getTime() };
            const tx = db.transaction(STORE_NAME, "readwrite");
            tx.objectStore(STORE_NAME).put(saveData, "last_session");
        }

        function loadState() {
            const tx = db.transaction(STORE_NAME, "readonly");
            tx.objectStore(STORE_NAME).get("last_session").onsuccess = (e) => {
                const data = e.target.result;
                if (data) {
                    screenCount = data.screenCount || 1; 
                    canvas.loadFromJSON(data.canvas, () => {
                        const objectsToRemove = [];
                        canvas.getObjects().forEach(obj => {
                            if (obj.isBackground || (obj.type === 'rect' && obj.width >= SCREEN_WIDTH && obj.top === 0 && obj.left === 0)) {
                                currentBgFill = obj.fill; objectsToRemove.push(obj); 
                            }
                        });
                        objectsToRemove.forEach(obj => canvas.remove(obj));
                        updateWorkspace(); 
                        
                        let hasContent = false;
                        canvas.getObjects().forEach(obj => { 
                            if(obj === bgRect) return;
                            if (obj.type === 'image' || obj.type === 'i-text' || obj.type === 'text') {
                                hasContent = true;
                            }
                            
                            if(obj.type === 'image') {
                                obj.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                                obj.set('noScaleCache', false); 
                            } else if (obj.type === 'i-text' || obj.type === 'text') {
                                obj.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                                obj.set('shadow', null);
                                obj.set('objectCaching', false);
                            }
                            if (obj.lockMovementX) {
                                obj.set({ hasControls: false, borderColor: '#ff453a' });
                            }
                        });

                        if (!hasContent) {
                            addDefaultText();
                        }

                        drawGrid(); 
                        initViewport(); 
                        hideSplashScreen(); 
                    });
                } else { 
                    updateWorkspace(); 
                    drawGrid(); 
                    addDefaultText();
                    initViewport();
                    hideSplashScreen(); 
                }
            };
        }

        function triggerAutoSave() {
            if(isInternalUpdate) return;
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveState, 1000);
        }

        canvas.on('object:modified', triggerAutoSave); canvas.on('object:added', triggerAutoSave); canvas.on('object:removed', triggerAutoSave);
        
        function drawGrid() {
            gridLines.forEach(l => canvas.remove(l)); gridLines = [];
            for (let i = 1; i < screenCount; i++) {
                const line = new fabric.Line([i * SCREEN_WIDTH, 0, i * SCREEN_WIDTH, SCREEN_HEIGHT], {
                    stroke: '#007AFF', strokeWidth: 1, strokeDashArray: [5, 5], opacity: 0.3, selectable: false, evented: false, excludeFromExport: true
                });
                canvas.add(line); gridLines.push(line);
            }
            bringGridToFront();
        }
        function bringGridToFront() { gridLines.forEach(l => l.bringToFront()); }

        async function exportContent() {
            statusIndicator.innerText = "准备导出..."; 
            
            const originalVpt = canvas.viewportTransform.slice();
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            canvas.setWidth(screenCount * SCREEN_WIDTH);
            canvas.setHeight(SCREEN_HEIGHT);
            gridLines.forEach(l => l.visible = false);
            canvas.clipPath = null; canvas.renderAll();

            const blobs = [];
            for (let i = 0; i < screenCount; i++) {
                const dataURL = canvas.toDataURL({ format: 'png', quality: 1, multiplier: 2, left: i * SCREEN_WIDTH, top: 0, width: SCREEN_WIDTH, height: SCREEN_HEIGHT });
                const blob = await (await fetch(dataURL)).blob();
                blobs.push(blob);
            }

            let shareSuccess = false;
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            try {
                if (isMobile && navigator.share && navigator.canShare) {
                    const files = blobs.map((blob, i) => new File([blob], `spark_slice_${i+1}.png`, { type: 'image/png' }));
                    if (navigator.canShare({ files })) {
                        statusIndicator.innerText = "调起分享...";
                        await navigator.share({ files: files, title: 'Spark Canvas', text: '由 Spark Canvas 生成' });
                        shareSuccess = true;
                        statusIndicator.innerText = "已完成"; 
                    }
                }
            } catch (err) { console.log("Share skipped/cancelled", err); }

            if (!shareSuccess) {
                statusIndicator.innerText = "开始下载...";
                for (let i = 0; i < blobs.length; i++) {
                    statusIndicator.innerText = `下载中 ${i+1}/${blobs.length}`;
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blobs[i]); a.download = `spark_slice_${i + 1}.png`;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                    if (i < blobs.length - 1) await new Promise(r => setTimeout(r, 1500));
                }
                statusIndicator.innerText = "下载完成"; 
            }
            
            canvas.setViewportTransform(originalVpt); canvas.setWidth(originalWidth); canvas.setHeight(originalHeight);
            gridLines.forEach(l => l.visible = true); updateWorkspace(); canvas.requestRenderAll();
        }
        
        initDB();
    </script>
</body>
</html>

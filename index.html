<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <title>Spark Canvas v1.19</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='20' fill='%235213dc'/><path d='M50 20 C50 20 60 40 80 50 C60 60 50 80 50 80 C50 80 40 60 20 50 C40 40 50 20 50 20 Z' fill='white'/></svg>">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@100..900&family=Noto+Serif+SC:wght@100..900&family=Outfit:wght@100..900&display=swap" rel="stylesheet">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>

    <style>
        :root { 
            --bg-color: #121212; 
            --glass-bg: rgba(30, 30, 30, 0.65); 
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-highlight: rgba(255, 255, 255, 0.05);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            
            --accent-color: #5213dc; 
            --danger-color: #FF453A; 
            --text-main: #FFFFFF;
            --text-sub: #8E8E93;
        }
        
        html, body { 
            height: 100%; width: 100%; 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            overflow: hidden; 
            font-family: "Outfit", "Noto Sans SC", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; 
            background-color: var(--bg-color); 
            color: var(--text-main); margin: 0; 
            touch-action: none; 
            -webkit-user-select: none; user-select: none;
        }

        #splash-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: var(--bg-color);
            z-index: 99999;
            display: flex; justify-content: center; align-items: center;
            transition: opacity 0.6s ease-out, visibility 0.6s;
        }
        
        #splash-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .splash-content {
            text-align: center;
            animation: breathe 3s infinite ease-in-out;
        }

        .splash-title {
            font-family: 'Outfit', sans-serif;
            font-size: 32px;
            font-weight: 700;
            color: #fff;
            letter-spacing: 1px;
            text-shadow: 0 0 20px rgba(255,255,255,0.1);
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        #status-indicator { display: none !important; }

        #canvas-wrapper { 
            width: 100vw; height: 100dvh; 
            overflow: hidden;
            background-color: var(--bg-color); 
            background-image: radial-gradient(#333 1px, transparent 1px);
            background-size: 20px 20px;
            display: flex; justify-content: center; align-items: center;
        }
        
        .canvas-container { margin: 0 auto; background: transparent !important; }
        canvas { background: transparent !important; }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            box-sizing: border-box;
        }

        .side-glass-capsule {
            background: var(--glass-bg);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            box-shadow: var(--glass-shadow);
            box-sizing: border-box;
            
            border-radius: 20px; 
            padding: 6px; 
            
            display: flex; 
            flex-direction: column; 
            gap: 6px;
            z-index: 90;
        }

        .side-bar {
            position: fixed; 
        }

        .side-bar-bottom {
            position: fixed; 
        }

        .side-btn {
            width: 36px; height: 36px;
            border-radius: 14px;
            
            display: flex; align-items: center; justify-content: center;
            font-size: 18px;
            color: var(--text-sub);
            cursor: pointer; 
            transition: all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
            border: 1px solid transparent;
        }
        
        .side-btn:hover { 
            color: var(--text-main); 
            background: var(--glass-highlight);
            transform: scale(1.15);
            border-color: rgba(255,255,255,0.1);
        }
        .side-btn:active { transform: scale(0.9); }

        .side-btn.danger { color: #666; }
        .side-btn.danger:hover { background: rgba(255, 69, 58, 0.15); color: var(--danger-color); border-color: var(--danger-color); }

        .bottom-ui-wrapper {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            display: flex;
            align-items: center;
            justify-content: center; 
            gap: 16px; 
            z-index: 100;
            width: 100%; 
            pointer-events: none; 
        }

        .bottom-dock-container {
            position: relative; 
            left: auto; bottom: auto; transform: none;
            
            padding: 10px;
            border-radius: 28px;
            
            display: flex; 
            align-items: center; 
            gap: 12px;
            margin-bottom: 0;
            pointer-events: auto; 
        }

        .dock-btn {
            width: 48px; height: 48px;
            border-radius: 18px; 
            display: flex; align-items: center; justify-content: center;
            font-size: 22px; color: var(--text-main);
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 1px solid transparent;
        }

        .dock-btn:hover { background: var(--glass-highlight); transform: scale(1.15); }
        .dock-btn:active { transform: scale(0.9); }

        #virtual-shift-btn {
            width: 48px; height: 48px; 
            border-radius: 18px; 
            background: var(--glass-bg);
            backdrop-filter: blur(24px) saturate(180%);
            -webkit-backdrop-filter: blur(24px) saturate(180%);
            border: 1px solid var(--glass-border);
            color: var(--text-sub);
            display: flex; align-items: center; justify-content: center;
            
            font-family: 'Outfit', sans-serif;
            font-size: 11px; 
            font-weight: 800;
            letter-spacing: 0.5px;
            
            transition: all 0.1s;
            box-shadow: var(--glass-shadow);
            cursor: pointer;
            pointer-events: auto; 
        }

        #virtual-shift-btn.active {
            background-color: var(--accent-color);
            color: white !important;
            transform: scale(0.95);
            border-color: var(--accent-color);
            box-shadow: 0 0 15px rgba(82, 19, 220, 0.4);
        }

        @media (min-width: 768px) and (pointer: fine) {
            #virtual-shift-btn {
                display: none !important;
            }
        }

        #bg-panel { 
            display: none; position: absolute; left: 50%; transform: translateX(-50%); 
            
            border-radius: 20px; 
            padding: 10px 14px 14px 14px; 
            
            z-index: 90; animation: panelUp 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); 
            width: 210px; 
            bottom: calc(80px + env(safe-area-inset-bottom, 0px));
            
            margin-left: 32px;
        }
        
        @media (min-width: 768px) and (pointer: fine) {
            #bg-panel { margin-left: 0; }
        }

        @keyframes panelUp { from { opacity: 0; transform: translate(-50%, 20px) scale(0.95); } to { opacity: 1; transform: translate(-50%, 0) scale(1); } }
        
        .panel-title { font-size: 10px; color: #e0e0e0; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; text-align: center; font-weight: 700; }
        
        .bg-options { display: flex; justify-content: space-between; gap: 8px; align-items: center; }
        
        .bg-option { 
            width: 44px; height: 44px; 
            
            border-radius: 16px; 
            
            border: 2px solid rgba(255,255,255,0.1); 
            cursor: pointer; 
            display: flex; align-items: center; justify-content: center; 
            overflow: hidden; position: relative; 
            background: rgba(255,255,255,0.05);
            transition: all 0.2s; 
            color: #ddd;
            flex-shrink: 0; 
        }
        .bg-option:hover { border-color: #fff; transform: scale(1.05); color: white; background: rgba(255,255,255,0.1); }
        .bg-option:active { transform: scale(0.95); }

        .ratio-toggle {
            font-family: 'Outfit', sans-serif;
            font-weight: 700;
            font-size: 14px; 
            letter-spacing: 0.5px;
        }

        .color-input-wrapper input[type="color"] {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            opacity: 0; cursor: pointer;
        }
        
        .bg-option i { font-size: 20px; }

        #context-menu { 
            display: none; position: absolute; z-index: 2000; width: 170px; 
            border-radius: 16px; padding: 6px; 
            animation: menuFadeIn 0.2s cubic-bezier(0.25, 0.8, 0.25, 1); 
        }
        @keyframes menuFadeIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        
        .menu-header { font-size: 10px; color: #e0e0e0; padding: 4px 8px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; font-weight: 700; display: none; }
        
        .layer-controls { display: flex; justify-content: space-between; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 4px; margin-bottom: 6px; }
        .layer-btn { width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; cursor: pointer; font-size: 18px; color: #ccc; transition: background 0.2s; }
        .layer-btn:hover { background: rgba(255,255,255,0.15); color: white; }
        
        .menu-item { display: none; align-items: center; padding: 10px 10px; font-size: 13px; color: #eee; cursor: pointer; border-radius: 10px; transition: background 0.1s; margin-bottom: 2px; font-weight: 500; }
        .menu-item:hover, .menu-item:active { background: var(--accent-color); color: white; }
        .menu-item.delete { color: var(--danger-color); margin-top: 6px; border-top: 1px solid rgba(255,255,255,0.08); border-radius: 0 0 10px 10px; padding-top: 12px; }
        .menu-item.delete:hover { background: var(--danger-color); color: white; }
        .menu-icon-span { width: 24px; text-align: center; margin-right: 10px; font-size: 18px; }

        #menu-lock { display: none !important; }

        .text-colors-container { display: flex; gap: 6px; padding: 8px 4px; justify-content: space-around; border-bottom: 1px solid rgba(255,255,255,0.08); margin-bottom: 6px; }
        
        .text-color-dot { 
            width: 18px; height: 18px; 
            border-radius: 50%; 
            cursor: pointer; 
            border: 2px solid rgba(255,255,255,0.1); 
            transition: transform 0.2s; 
            flex-shrink: 0;
            box-sizing: border-box;
        }
        .text-color-dot:hover { transform: scale(1.2); border-color: white; }

        .align-toolbar { display: flex; gap: 4px; background: rgba(255,255,255,0.05); border-radius: 10px; padding: 4px; margin-bottom: 6px; }
        .align-btn { flex: 1; text-align: center; padding: 6px 0; font-size: 18px; color: #ccc; cursor: pointer; border-radius: 8px; transition: background 0.2s; }
        .align-btn:hover { background: rgba(255,255,255,0.15); color: white; }

        .control-row { display: none; justify-content: space-between; align-items: center; padding: 6px 10px; color: #ccc; font-size: 12px; margin-bottom: 2px; }
        .control-label { flex-grow: 1; opacity: 0.7; font-size: 12px; font-weight: 500; }
        .control-group { display: flex; gap: 6px; }
        .control-btn { background: rgba(255,255,255,0.1); border-radius: 6px; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.2s; font-weight: bold; color: #ddd; font-size: 16px; }
        .control-btn:hover { background: white; color: black; }
        .control-btn:active { transform: scale(0.9); }

        .font-selector-row { display: none; padding: 2px; margin-bottom: 6px; }
        .font-toggle-btn, .filter-toggle-btn { display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 10px 10px; background: rgba(255,255,255,0.05); border-radius: 10px; cursor: pointer; color: #ddd; font-size: 13px; font-weight: 500; transition: background 0.2s; }
        .font-toggle-btn:hover, .filter-toggle-btn:hover { background: rgba(255,255,255,0.15); color: white; }

        .popup-options-list {
             display: none; flex-direction: column; gap: 4px;
             position: absolute; 
             left: calc(105% - 100px); 
             top: 100px;
             border-radius: 14px; padding: 6px; min-width: 110px;
             z-index: 2001;
        }
        .popup-options-list.active { display: flex; }
        .popup-option { padding: 10px 14px; font-size: 14px; color: #ccc; cursor: pointer; border-radius: 8px; text-align: left; white-space: nowrap; transition: background 0.2s; }
        .popup-option:hover { background: var(--accent-color); color: white; }

        .show-always { display: flex !important; }
        .show-header { display: block !important; }

        #confirm-modal, #info-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); z-index: 3000; animation: fadeIn 0.3s; }

        .modal-box { 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: #222; border: 1px solid #444; 
            border-radius: 16px; 
            
            /* [V1.19 UI Tweaks] Increased padding + increased width to maintain inner content width */
            padding: 35px; 
            width: 280px; 
            max-width: 85%; 
            
            text-align: center; 
            box-shadow: 0 25px 60px rgba(0,0,0,0.6); 
            animation: popIn 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes popIn { from { opacity: 0; transform: translate(-50%, -40%) scale(0.9); } to { opacity: 1; transform: translate(-50%, -50%) scale(1); } }

        .modal-title { 
            font-size: 18px; font-weight: 700; 
            margin-bottom: 32px; /* [V1.19] Increased margin below title */
            color: white; letter-spacing: 0.5px; 
        }
        .modal-desc { font-size: 14px; color: #999; margin-bottom: 24px; line-height: 1.5; }
        .modal-actions { display: flex; gap: 12px; justify-content: center; }
        
        .modal-btn { 
            flex: 1; padding: 12px; border-radius: 10px; 
            cursor: pointer; border: none; font-size: 14px; font-weight: 600; 
            transition: transform 0.1s; 
        }
        .modal-btn:active { transform: scale(0.95); }
        .modal-btn.cancel { background: #3a3a3c; color: #fff; }
        .modal-btn.cancel:hover { background: #48484a; }
        .modal-btn.confirm { background: var(--danger-color); color: white; }
        .modal-btn.confirm:hover { background: #ff5b50; }
        
        .modal-btn.primary { background: var(--accent-color); color: white; }
        .modal-btn.primary:hover { background: #3a32db; }

        .info-list { text-align: left; font-size: 14px; color: #bbb; margin-bottom: 25px; padding: 0 5px; }
        
        .info-item { 
            display: flex; align-items: center; gap: 16px; 
            margin-bottom: 16px; 
            padding-bottom: 16px; 
            border-bottom: 1px solid rgba(255,255,255,0.1); /* [V1.19] Added separator */
        }
        /* Last item has no border */
        .info-item:last-child {
            border-bottom: none;
            margin-bottom: 25px;
            padding-bottom: 0;
        }

        .info-icon { font-size: 32px; width: 32px; text-align: center; color: var(--accent-color); flex-shrink: 0; }
        
        /* [V1.19] Class for uniform text sizing in info modal */
        .info-text-line {
            display: block;
            font-size: 14px;
            line-height: 1.5;
        }

        .modal-footer { margin-top: 25px; padding-top: 15px; border-top: 1px solid rgba(255,255,255,0.1); }
        .social-links { display: flex; justify-content: center; gap: 24px; margin-bottom: 8px; }
        .social-icon { font-size: 20px; color: #666; cursor: pointer; transition: all 0.2s; text-decoration: none; }
        .social-icon:hover { color: var(--text-main); transform: scale(1.1); }
        .made-with { font-size: 10px; color: #555; display: flex; align-items: center; justify-content: center; gap: 3px; }

        #file-input, #bg-file-input { display: none; }
    </style>
</head>
<body>

    <div id="splash-screen">
        <div class="splash-content">
            <div class="splash-title">Spark Canvas</div>
        </div>
    </div>

    <script>
        if (sessionStorage.getItem('spark_session_active')) {
            document.getElementById('splash-screen').style.display = 'none';
        } else {
            sessionStorage.setItem('spark_session_active', 'true');
        }
    </script>

    <div id="status-indicator">ÂáÜÂ§áÂ∞±Áª™</div>
    <div id="canvas-wrapper"><canvas id="c"></canvas></div>

    <div class="side-bar side-glass-capsule">
        <div class="side-btn" onclick="addScreen()" title="Â¢ûÂä†È°µÈù¢"><i class="ri-file-add-line"></i></div>
        <div class="side-btn" onclick="removeScreen()" title="Âà†Èô§È°µÈù¢"><i class="ri-delete-back-2-line"></i></div>
    </div>

    <div class="side-bar-bottom side-glass-capsule">
        <div class="side-btn" onclick="showInfoModal()" title="Êìç‰ΩúÊåáÂçó"><i class="ri-information-line"></i></div>
        <div class="side-btn danger" onclick="showModal()" title="Ê∏ÖÁ©∫"><i class="ri-delete-bin-line"></i></div>
    </div>

    <div class="bottom-ui-wrapper">
        <div id="virtual-shift-btn" title="Â§öÈÄâÊ®°Âºè (Êåâ‰Ωè)">
            Shift
        </div>

        <div class="bottom-dock-container glass-panel">
            <div class="dock-btn" onclick="document.getElementById('file-input').click()" title="Ê∑ªÂä†ÂõæÁâá"><i class="ri-image-add-line"></i></div>
            <div class="dock-btn" onclick="addText()" title="Ê∑ªÂä†ÊñáÂ≠ó"><i class="ri-text"></i></div>
            <div class="dock-btn" onclick="toggleBgPanel()" title="ÁîªÂ∏ÉËÆæÁΩÆ"><i class="ri-settings-4-line"></i></div> 
            <div class="dock-btn" onclick="exportContent()" title="ÂØºÂá∫"><i class="ri-download-2-line"></i></div>
        </div>
    </div>

    <div id="bg-panel" class="glass-panel">
        <div class="panel-title">ÁîªÂ∏ÉËÆæÁΩÆ</div>
        <div class="bg-options">
            
            <div class="bg-option ratio-toggle" onclick="toggleAspectRatio()" id="ratio-toggle-btn" title="ÂàáÊç¢ÊØî‰æã">1:1</div>

            <div class="bg-option color-input-wrapper" id="color-picker-btn" title="ËÉåÊôØÈ¢úËâ≤" style="background-color: #ffffff">
                <input type="color" id="bg-picker" value="#ffffff" onchange="changeBackgroundColor(this.value)">
            </div>

            <div class="bg-option add-btn" onclick="document.getElementById('bg-file-input').click()" title="ÂõæÁâáËÉåÊôØ"><i class="ri-image-2-line"></i></div>
        </div>
    </div>

    <div id="confirm-modal">
        <div class="modal-box">
            <div class="modal-title">Ê∏ÖÁ©∫ÁîªÂ∏É</div>
            <div class="modal-desc">Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂÜÖÂÆπÂêóÔºü<br>Ê≠§Êìç‰ΩúÊó†Ê≥ïÊí§ÈîÄ„ÄÇ</div>
            <div class="modal-actions">
                <button class="modal-btn cancel" onclick="closeModal()">ÂèñÊ∂à</button>
                <button class="modal-btn confirm" onclick="executeClear()">Á°ÆËÆ§Ê∏ÖÁ©∫</button>
            </div>
        </div>
    </div>

    <div id="info-modal">
        <div class="modal-box">
            <div class="modal-title">Spark Canvas</div>
            <div class="info-list">
                <div class="info-item">
                    <i class="info-icon ri-computer-line"></i>
                    <div>
                        <span class="info-text-line">ÂõæÁâá/ÊñáÂ≠ó‰∏ä <b>Âè≥ÈîÆ</b> Âî§Ëµ∑ËèúÂçï</span>
                        <span class="info-text-line">Êåâ‰Ωè Shift <b>Ê°ÜÈÄâ/Â§öÈÄâ</b> ÂØπË±°</span>
                    </div>
                </div>
                <div class="info-item">
                    <i class="info-icon ri-smartphone-line"></i> 
                    <div>
                        <span class="info-text-line">ÂõæÁâá/ÊñáÂ≠ó‰∏ä <b>ÈïøÊåâ</b> Âî§Ëµ∑ËèúÂçï</span>
                        <span class="info-text-line">Êåâ‰Ωè ËôöÊãüShift <b>Ê°ÜÈÄâ</b> ÂØπË±°</span>
                    </div>
                </div>
                <div class="info-item">
                    <i class="info-icon ri-fullscreen-line"></i> 
                    <span class="info-text-line">ÂèåÂáªÂõæÁâá <b>Èì∫Êª°/ÂàáÊç¢</b> Ê®°Âºè</span>
                </div>
            </div>
            <div class="modal-actions">
                <button class="modal-btn primary" onclick="closeInfoModal()">Áü•ÈÅì‰∫Ü</button>
            </div>
            <div class="modal-footer">
                <div class="social-links">
                    <a href="#" class="social-icon" title="Â∞èÁ∫¢‰π¶"><i class="ri-book-2-fill"></i></a> 
                    <a href="#" class="social-icon" title="Weibo"><i class="ri-weibo-fill"></i></a>
                    <a href="#" class="social-icon" title="X"><i class="ri-twitter-x-fill"></i></a>
                    <a href="#" class="social-icon" title="Instagram"><i class="ri-instagram-fill"></i></a>
                </div>
                <div class="made-with">Made with <i class="ri-heart-fill"></i></div>
            </div>
        </div>
    </div>

    <div id="context-menu" class="glass-panel">
        <div class="menu-header show-header">ÂõæÂ±Ç Layer</div>
        <div class="layer-controls">
            <div class="layer-btn" onclick="menuAction('top')"><i class="ri-arrow-up-double-line"></i></div>
            <div class="layer-btn" onclick="menuAction('up')"><i class="ri-arrow-up-s-line"></i></div>
            <div class="layer-btn" onclick="menuAction('down')"><i class="ri-arrow-down-s-line"></i></div>
            <div class="layer-btn" onclick="menuAction('bottom')"><i class="ri-arrow-down-double-line"></i></div>
        </div>
        
        <div class="menu-item show-always" id="menu-lock" onclick="menuAction('lock-toggle')">
            <i class="menu-icon-span ri-lock-line"></i> <span id="menu-lock-text">ÈîÅÂÆö</span>
        </div>

        <div class="menu-header image-menu-item">ÊïàÊûú Effect</div>
        <div class="menu-item image-menu-item" onclick="menuAction('flipX')"><i class="menu-icon-span ri-arrow-left-right-line"></i> Ê∞¥Âπ≥ÁøªËΩ¨</div>
        <div class="menu-item image-menu-item" onclick="menuAction('shadow')"><i class="menu-icon-span ri-drop-line"></i> ÊäïÂΩ±</div>

        <div class="menu-item image-menu-item" onclick="toggleFilterList()">
            <i class="menu-icon-span ri-contrast-drop-line"></i> Êª§Èïú Filter <i class="ri-arrow-right-s-line" id="filter-arrow-icon" style="margin-left:auto"></i>
        </div>

        <div id="filter-options-wrapper" class="popup-options-list glass-panel">
            <div class="popup-option" onclick="applyFilter('bw')">ÈªëÁôΩ B&W</div>
            <div class="popup-option" onclick="applyFilter('cyber')">ËµõÂçö Cyber</div>
            <div class="popup-option" onclick="applyFilter('sunset')">ËêΩÊó• Sunset</div>
            <div class="popup-option" onclick="applyFilter('violet')">Á¥´ÁΩóÂÖ∞ Violet</div>
            <div class="popup-option" onclick="applyFilter('none')">Êó† None</div>
        </div>

        <div class="menu-header text-menu-item">ÊñáÂ≠óËÆæÁΩÆ</div>
        
        <div class="font-selector-row text-menu-item">
            <div class="font-toggle-btn" onclick="toggleFontList()">
                <span>Â≠ó‰Ωì Font</span> <i class="ri-arrow-right-s-line" id="font-arrow-icon"></i>
            </div>
        </div>
        
        <div id="font-options-wrapper" class="popup-options-list glass-panel">
            <div class="popup-option" style="font-family: 'Noto Sans SC', sans-serif" onclick="changeFont('\'Noto Sans SC\', sans-serif')">ÊÄùÊ∫êÈªë‰Ωì</div>
            <div class="popup-option" style="font-family: 'Noto Serif SC', serif" onclick="changeFont('\'Noto Serif SC\', serif')">ÊÄùÊ∫êÂÆã‰Ωì</div>
            <div class="popup-option" style="font-family: 'Outfit', sans-serif" onclick="changeFont('\'Outfit\', sans-serif')">Outfit</div>
        </div>

        <div class="text-colors-container text-menu-item">
            <div class="text-color-dot" style="background: #000000" onclick="changeTextColor('#000000')"></div>
            <div class="text-color-dot" style="background: #ffffff" onclick="changeTextColor('#ffffff')"></div>
            <div class="text-color-dot" style="background: #FFCC00" onclick="changeTextColor('#FFCC00')"></div>
            <div class="text-color-dot" style="background: #34C759" onclick="changeTextColor('#34C759')"></div>
            <div class="text-color-dot" style="background: #5213dc" onclick="changeTextColor('#5213dc')"></div>
            <div class="text-color-dot" style="background: #FF3B30" onclick="changeTextColor('#FF3B30')"></div>
        </div>
        
        <div class="align-toolbar text-menu-item">
            <div class="align-btn" onclick="menuAction('align-left')"><i class="ri-align-left"></i></div>
            <div class="align-btn" onclick="menuAction('align-center')"><i class="ri-align-center"></i></div>
            <div class="align-btn" onclick="menuAction('align-right')"><i class="ri-align-right"></i></div>
        </div>

        <div class="control-row text-menu-item">
            <span class="control-label">Â≠óÈáç Weight</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('weight-up')"><i class="ri-add-line"></i></div>
                <div class="control-btn" onclick="menuAction('weight-down')"><i class="ri-subtract-line"></i></div>
            </div>
        </div>
        <div class="control-row text-menu-item">
            <span class="control-label">Â≠óË∑ù Spacing</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('spacing-up')"><i class="ri-add-line"></i></div>
                <div class="control-btn" onclick="menuAction('spacing-down')"><i class="ri-subtract-line"></i></div>
            </div>
        </div>
        <div class="control-row text-menu-item">
            <span class="control-label">Ë°åÈ´ò Height</span>
            <div class="control-group">
                <div class="control-btn" onclick="menuAction('line-height-up')"><i class="ri-add-line"></i></div>
                <div class="control-btn" onclick="menuAction('line-height-down')"><i class="ri-subtract-line"></i></div>
            </div>
        </div>

        <div class="menu-item show-always" onclick="menuAction('duplicate')"><i class="menu-icon-span ri-file-copy-line"></i> Â§çÂà∂</div>
        <div class="menu-item delete show-always" onclick="menuAction('delete')"><i class="menu-icon-span ri-delete-bin-line"></i> Âà†Èô§</div>
    </div>
    
    <input type="file" id="file-input" accept="image/*" multiple onchange="handleFiles(this.files)">
    <input type="file" id="bg-file-input" accept="image/*" onchange="handleBgFile(this.files)">

    <script>
        // V2.10 ÂêØÂä®È°µÊéßÂà∂
        const appStartTime = Date.now();
        const SPLASH_MIN_DURATION = 1600; 
        let splashHidden = false; 

        function hideSplashScreen() {
            const splash = document.getElementById('splash-screen');
            if (!splash || splash.style.display === 'none') {
                splashHidden = true;
                return;
            }
            if (splashHidden) return;
            splashHidden = true;

            const now = Date.now();
            const elapsed = now - appStartTime;
            const remaining = Math.max(0, SPLASH_MIN_DURATION - elapsed);

            setTimeout(() => {
                splash.classList.add('hidden');
                setTimeout(() => {
                    splash.style.display = 'none';
                }, 600); 
            }, remaining);
        }
        
        setTimeout(hideSplashScreen, 3000);

        const SCREEN_WIDTH = 540;
        let SCREEN_HEIGHT = 960; // ÈªòËÆ§ 9:16
        let screenCount = 1;
        fabric.textureSize = 2048; 

        // Â∏ÉÂ±ÄÁºìÂ≠ò
        let layoutState = { visualHeight: 0, availableHeight: 0 };

        const rotateIconImg = new Image();
        rotateIconImg.src = 'rotate.png';
        rotateIconImg.onload = function() { if(canvas) canvas.requestRenderAll(); }

        function renderCustomIcon(ctx, left, top, styleOverride, fabricObject) {
            const size = 20; 
            ctx.save(); ctx.translate(left, top); ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            
            ctx.beginPath(); ctx.arc(0, 0, size/2, 0, 2 * Math.PI); ctx.fillStyle = "#5213dc"; ctx.fill();
            
            ctx.shadowColor = "rgba(0,0,0,0.3)"; ctx.shadowBlur = 3; ctx.shadowOffsetY = 1;
            const iconSize = size * 0.7; 
            if (rotateIconImg.complete && rotateIconImg.naturalWidth !== 0) {
                 ctx.drawImage(rotateIconImg, -iconSize/2, -iconSize/2, iconSize, iconSize);
            } else {
                ctx.fillStyle = "white"; ctx.beginPath(); ctx.arc(0,0, 3, 0, 2*Math.PI); ctx.fill();
            }
            ctx.restore();
        }

        fabric.Object.prototype.set({
            snapAngle: 90, snapThreshold: 3,
            cornerStyle: 'circle', cornerColor: '#5213dc', borderColor: '#5213dc',
            transparentCorners: false, borderScaleFactor: 2, cornerSize: 10,
            centeredScaling: false, lockUniScaling: true,
            lockMovementX: false, lockMovementY: false
        });

        fabric.Object.prototype.controls.mtr = new fabric.Control({
            x: 0, y: -0.5, offsetY: -25, 
            actionHandler: fabric.controlsUtils.rotationWithSnapping,
            cursorStyle: 'crosshair', render: renderCustomIcon, actionName: 'rotate'
        });

        // -----------------------------------------------------------
        // V0.95 Feature: Canvas Lock/Unlock Control
        // -----------------------------------------------------------
        
        function getRemixIconChar(className) {
            const el = document.createElement('i');
            el.className = className;
            el.style.position = 'absolute'; 
            el.style.visibility = 'hidden';
            document.body.appendChild(el);
            const content = window.getComputedStyle(el, ':before').getPropertyValue('content');
            document.body.removeChild(el);
            return content.replace(/['"]/g, '');
        }

        let ICON_LOCK = 'üîí';
        let ICON_UNLOCK = 'üîì';
        
        setTimeout(() => {
            ICON_LOCK = getRemixIconChar('ri-lock-line') || 'üîí';
            ICON_UNLOCK = getRemixIconChar('ri-lock-unlock-line') || 'üîì';
        }, 1000);

        function renderLockIcon(ctx, left, top, styleOverride, fabricObject) {
            const size = 20; 
            let isLocked = fabricObject.lockMovementX;
            if (fabricObject.type === 'activeSelection' && fabricObject._objects?.length > 0) {
                 if (fabricObject._objects[0].lockMovementX) isLocked = true;
            }

            ctx.save();
            ctx.translate(left, top);
            ctx.rotate(fabric.util.degreesToRadians(fabricObject.angle));
            
            ctx.beginPath();
            ctx.arc(0, 0, size/2, 0, 2 * Math.PI);
            
            if (isLocked) {
                ctx.fillStyle = "#FF453A"; 
            } else {
                ctx.fillStyle = "#34C759"; 
            }
            ctx.fill();
            
            ctx.fillStyle = "#FFFFFF";
            ctx.font = "normal 12px remixicon";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(isLocked ? ICON_LOCK : ICON_UNLOCK, 0, 0.5);
            
            ctx.restore();
        }

        function updateVisualState(target, isLocked) {
            if (!target) return;
            
            if (isLocked && target.isEditing) {
                target.exitEditing();
            }

            if (isLocked) {
                target.set('hasControls', true); 
                target.setControlsVisibility({
                    tl: false, tr: false, bl: false, br: false, mtr: false, 
                    ml: false, mr: false, mt: false, mb: false
                });
                target.set('borderColor', '#FF453A');
                target.set('cornerColor', 'transparent');
            } else {
                target.set('hasControls', true);
                target.setControlsVisibility({
                    tl: true, tr: true, bl: true, br: true, mtr: true,
                    ml: false, mr: false, mt: false, mb: false
                });
                target.set('borderColor', '#5213dc');
                target.set('cornerColor', '#5213dc');
            }
        }

        function toggleLockHandler(eventData, transformData) {
            const target = transformData.target;
            let isLocked = target.lockMovementX;
            if (target.type === 'activeSelection' && target._objects.length > 0) {
                isLocked = target._objects[0].lockMovementX;
            }
            
            const nextStateLocked = !isLocked;
            const lockProps = {
                lockMovementX: nextStateLocked, lockMovementY: nextStateLocked,
                lockRotation: nextStateLocked, lockScalingX: nextStateLocked, lockScalingY: nextStateLocked
            };

            if (target.type === 'activeSelection') {
                target.forEachObject(o => o.set(lockProps));
                target.set(lockProps);
            } else {
                target.set(lockProps);
            }

            updateVisualState(target, nextStateLocked);
            target.canvas.requestRenderAll();
            triggerAutoSave();
            return true;
        }

        fabric.Object.prototype.controls.lockCtrl = new fabric.Control({
            x: 0.5, y: -0.5,
            offsetX: 0, offsetY: -25,
            cursorStyle: 'pointer',
            actionName: 'toggleLock',
            mouseUpHandler: toggleLockHandler,
            render: renderLockIcon,
            sizeX: 24, sizeY: 24 
        });

        // -----------------------------------------------------------

        const canvas = new fabric.Canvas('c', {
            width: window.innerWidth, height: window.innerHeight,
            backgroundColor: null, 
            preserveObjectStacking: true, 
            fireRightClick: true, stopContextMenu: true,
            selection: true, 
            allowTouchScrolling: false,
            targetFindTolerance: 20 
        });

        // ==========================================
        // 1. ‰øÆÂ§çÔºöÂº∫Âà∂ Cover ÁÆóÊ≥ï (Êó†ËßÜ DPI/ËßÜÁΩëËÜúÂ±èÂ∑ÆÂºÇ)
        // ==========================================
        function handleImageSmartToggle(target) {
            // ÊéíÈô§Êó†ÂÖ≥ÂØπË±°
            if (!target || target.type !== 'image' || target === bgRect) return;

            // --- ÂàÜÊîØ AÔºöËß£Áªë (ÁßªÈô§ÈÅÆÁΩ©) ---
            if (target.clipPath) {
                target.set('clipPath', null);
                target.dirty = true;
                canvas.requestRenderAll();
                triggerAutoSave();
                console.log("[Toggle] Mask Removed (Free Mode)");
                return;
            }

            // --- ÂàÜÊîØ BÔºöÈì∫Êª° (Ê∑ªÂä†ÈÅÆÁΩ©) ---
            const screenW = SCREEN_WIDTH;
            const screenH = SCREEN_HEIGHT;

            // ËÆ°ÁÆóÂΩíÂ±ûÈ°µÈù¢
            const objCenter = target.getCenterPoint();
            let pageIndex = Math.floor(objCenter.x / screenW);
            if (pageIndex < 0) pageIndex = 0;
            if (pageIndex >= screenCount) pageIndex = screenCount - 1;

            // ÁõÆÊ†á‰ΩçÁΩÆ
            const destX = (pageIndex * screenW) + (screenW / 2);
            const destY = screenH / 2;

            // 1. Âº∫Âà∂ÈáçÁΩÆÁä∂ÊÄÅÔºåÁ°Æ‰øùËÆ°ÁÆóÂü∫‰∫éÂéüÂßãÂ∞∫ÂØ∏
            target.set({
                angle: 0,
                scaleX: 1,
                scaleY: 1
            });

            // 2. Ê†∏ÂøÉ‰øÆÂ§çÔºöÁ∫ØÊï∞Â≠¶ËÆ°ÁÆó Cover ÊØî‰æã (CSS Object-Fit: Cover ÁÆóÊ≥ï)
            // ÂàÜÂà´ËÆ°ÁÆóÂÆΩÂ∫¶Â°´Êª°ÂíåÈ´òÂ∫¶Â°´Êª°ÊâÄÈúÄÁöÑÁº©ÊîæÂÄçÁéá
            const scaleToFillWidth = screenW / target.width;
            const scaleToFillHeight = screenH / target.height;

            // Âèñ‰∏§ËÄÖÁöÑÊúÄÂ§ßÂÄºÔºåÁ°Æ‰øùÁü≠Ëæπ‰πüËÉΩÂ°´Êª°
            const finalScale = Math.max(scaleToFillWidth, scaleToFillHeight);

            // 3. Â∫îÁî®Áº©ÊîæÂíåÂÆö‰Ωç
            target.set({
                scaleX: finalScale,
                scaleY: finalScale,
                left: destX, 
                top: destY,
                originX: 'center', 
                originY: 'center'
            });

            // 4. Ê∑ªÂä†ÈÅÆÁΩ© (‰∏çÂèØ‰∫§‰∫í)
            const clipRect = new fabric.Rect({
                left: pageIndex * screenW, top: 0,
                width: screenW, height: screenH,
                absolutePositioned: true,
                evented: false, 
                selectable: false
            });
            
            target.set('clipPath', clipRect);

            // 5. Âà∑Êñ∞
            target.setCoords();
            canvas.requestRenderAll();
            triggerAutoSave();
            console.log(`[Toggle] Cover Mode | Scale: ${finalScale.toFixed(4)}`);
        }

        // ==========================================
        // 2. Ê°åÈù¢Á´ØÁõëÂê¨ (Â§çÁî®ÈÄªËæë) + ÊñáÂ≠óÂèåÂáªÁºñËæë
        // ==========================================
        canvas.on('mouse:dblclick', function(opt) {
            const target = opt.target;
            if (!target) return;

            // ÂõæÁâá Toggle ÈÄªËæë
            if (target.type === 'image') {
                handleImageSmartToggle(target);
            }
            // [V1.17] Ê°åÈù¢Á´ØÊñáÂ≠óÂèåÂáªÊâçËøõÂÖ•ÁºñËæë
            else if ((target.type === 'i-text' || target.type === 'text') && !target.lockMovementX) {
                target.set('editable', true);
                target.enterEditing();
                target.selectAll();
            }
        });

        function handleLockStateSelection(e) {
            const target = e.selected ? e.selected[0] : e.target;
            if (!target) return;
            
            let isLocked = target.lockMovementX;
            if (target.type === 'activeSelection' && target._objects?.length > 0) {
                isLocked = target._objects[0].lockMovementX;
            }
            updateVisualState(target, isLocked);
        }
        canvas.on('selection:created', handleLockStateSelection);
        canvas.on('selection:updated', handleLockStateSelection);

        let isTextEditingMode = false;
        canvas.on('text:editing:entered', () => { isTextEditingMode = true; });
        
        // [V1.17] ÈÄÄÂá∫ÁºñËæëÂêéÔºåÂº∫Âà∂ÈîÅ‰Ωè editableÔºåÈò≤Ê≠¢ÂçïÂáªËØØËß¶
        canvas.on('text:editing:exited', (e) => { 
            isTextEditingMode = false;
            if(e.target) e.target.set('editable', false);
        });

        fabric.ActiveSelection.prototype.setControlsVisibility({
            mt: false, mb: false, ml: false, mr: false 
        });

        let isVirtualShiftPressed = false;
        const virtualShiftBtn = document.getElementById('virtual-shift-btn');

        const originalIsSelectionKeyPressed = fabric.Canvas.prototype._isSelectionKeyPressed;
        fabric.Canvas.prototype._isSelectionKeyPressed = function(e) {
            return isVirtualShiftPressed || (e && e.shiftKey);
        };

        virtualShiftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault(); 
            isVirtualShiftPressed = true;
            virtualShiftBtn.classList.add('active');
            canvas.selection = true; 
        }, { passive: false });

        virtualShiftBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            isVirtualShiftPressed = false;
            virtualShiftBtn.classList.remove('active');
        }, { passive: false });
        
        virtualShiftBtn.addEventListener('mousedown', () => {
            isVirtualShiftPressed = true;
            virtualShiftBtn.classList.add('active');
            canvas.selection = true;
        });
        virtualShiftBtn.addEventListener('mouseup', () => {
            isVirtualShiftPressed = false;
            virtualShiftBtn.classList.remove('active');
        });

        let gridLines = [];
        const contextMenu = document.getElementById('context-menu');
        const bgPanel = document.getElementById('bg-panel');
        const statusIndicator = document.getElementById('status-indicator');
        const confirmModal = document.getElementById('confirm-modal');
        const infoModal = document.getElementById('info-modal');
        const sideBar = document.querySelector('.side-bar');
        const sideBarBottom = document.querySelector('.side-bar-bottom');
        const ratioToggleBtn = document.getElementById('ratio-toggle-btn'); 

        const DB_NAME = "SparkCanvasDB"; const STORE_NAME = "sessions";
        let db; let saveTimeout;

        let isInternalUpdate = false;
        let currentBgFill = '#ffffff'; 
        let bgRect; 

        // V1.10 Update: Close panel after toggle
        function toggleAspectRatio() {
            const OLD_HEIGHT = SCREEN_HEIGHT;
            let NEW_HEIGHT;
            let btnText;

            if (Math.abs(OLD_HEIGHT - 960) < 5) {
                // Current: 9:16 -> Target: 1:1 -> Next Button: 3:4
                NEW_HEIGHT = 540;
                btnText = "3:4";
            } else if (Math.abs(OLD_HEIGHT - 540) < 5) {
                // Current: 1:1 -> Target: 3:4 -> Next Button: 9:16
                NEW_HEIGHT = 720;
                btnText = "9:16";
            } else {
                // Current: 3:4 -> Target: 9:16 -> Next Button: 1:1
                NEW_HEIGHT = 960;
                btnText = "1:1";
            }

            const heightDiff = NEW_HEIGHT - OLD_HEIGHT;
            const offset = heightDiff / 2;

            canvas.getObjects().forEach(obj => {
                if (obj.isBackground || obj.excludeFromExport) return;
                
                obj.top += offset;
                obj.setCoords(); 
            });

            SCREEN_HEIGHT = NEW_HEIGHT;
            if(ratioToggleBtn) ratioToggleBtn.innerText = btnText;

            updateWorkspace(); 
            drawGrid();
            initViewport();
            triggerAutoSave();
            
            canvas.requestRenderAll();
            
            // V1.10 Add: Close panel immediately
            bgPanel.style.display = 'none';
        }

        function updateWorkspace() {
            isInternalUpdate = true;
            if (bgRect && canvas.contains(bgRect)) canvas.remove(bgRect);
            
            bgRect = new fabric.Rect({
                left: 0, top: 0,
                width: screenCount * SCREEN_WIDTH,
                height: SCREEN_HEIGHT, 
                fill: currentBgFill,
                selectable: false, evented: false, 
                isBackground: true 
            });
            canvas.add(bgRect);
            canvas.sendToBack(bgRect);

            canvas.clipPath = new fabric.Rect({
                left: 0, top: 0,
                width: screenCount * SCREEN_WIDTH,
                height: SCREEN_HEIGHT, 
                absolutePositioned: false 
            });

            drawGrid();

            isInternalUpdate = false;
        }

        function updateSideBarPosition() {
            const vpt = canvas.viewportTransform;
            if(!vpt) return;
            const zoom = canvas.getZoom();
            
            const contentRightEdge = vpt[4] + (screenCount * SCREEN_WIDTH * zoom);
            const contentTopEdge = vpt[5]; 
            const contentBottomEdge = vpt[5] + (SCREEN_HEIGHT * zoom);

            const newLeft = (contentRightEdge + 12) + 'px'; 
            
            sideBar.style.left = newLeft; 
            sideBar.style.top = contentTopEdge + 'px'; 
            
            if(sideBarBottom) {
                sideBarBottom.style.left = newLeft;
                sideBarBottom.style.top = (contentBottomEdge - 93) + 'px'; 
            }
        }

        function focusOnPage(index) {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const zoom = canvas.getZoom();
            
            const isMobile = winW < 768; 
            
            let targetY;
            if (isMobile) {
                const availableSpaceTop = 30; 
                const availableSpaceBottom = winH - 160; 
                const visualSpaceCenterY = (availableSpaceTop + availableSpaceBottom) / 2;
                const contentHalfHeight = (SCREEN_HEIGHT * zoom) / 2;
                targetY = visualSpaceCenterY - contentHalfHeight;
            } else {
                const availableSpaceTop = 0;
                const availableSpaceBottom = winH - 100;
                const visualSpaceCenterY = (availableSpaceTop + availableSpaceBottom) / 2;
                const contentHalfHeight = (SCREEN_HEIGHT * zoom) / 2;
                targetY = visualSpaceCenterY - contentHalfHeight + 10;
            }

            const vpt = canvas.viewportTransform;
            vpt[4] = (winW / 2) - ((index * SCREEN_WIDTH + SCREEN_WIDTH / 2) * zoom);
            vpt[5] = targetY;

            canvas.requestRenderAll();
            updateSideBarPosition();
        }

        function initViewport() {
            const winW = window.innerWidth;
            const winH = window.innerHeight;
            const isMobile = winW < 768;
            
            canvas.setWidth(winW);
            canvas.setHeight(winH);
            
            const safeW = winW - (isMobile ? 34 : 40); 
            const safeH = winH - (isMobile ? 160 : 220); 
            
            const scaleX = safeW / SCREEN_WIDTH;
            const scaleY = safeH / SCREEN_HEIGHT; 
            let zoom = Math.min(scaleX, scaleY);
            
            if (zoom > 1) zoom = 1; 
            if (zoom < 0.1) zoom = 0.1;
            canvas.setZoom(zoom);

            layoutState.visualHeight = SCREEN_HEIGHT * zoom;
            layoutState.availableHeight = winH - 140; 

            focusOnPage(0);
            updateHitRegions(); 
        }
        
        function updateHitRegions() {
            canvas.forEachObject(obj => obj.setCoords());
        }

        window.addEventListener('resize', () => {
            initViewport(); 
        });

        setTimeout(() => {
            updateWorkspace();
            initViewport();
        }, 100);

        let isDraggingCanvas = false;
        let lastX, lastY;
        let mouseDownPoint = {x:0, y:0};
        let mouseDownTarget = null; 

        let velocityX = 0, velocityY = 0;
        let lastMoveTime = 0;
        let momentumID = null;

        function getClientPos(e) {
            if (e.touches && e.touches.length > 0) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        function getBroadType(type) {
            if (type === 'i-text' || type === 'text' || type === 'textbox') return 'text';
            if (type === 'image') return 'image';
            return 'other';
        }

        function updateContextMenuState(target) {
            const lockItemText = document.getElementById('menu-lock-text');
            const lockIcon = document.querySelector('#menu-lock .menu-icon-span');
            
            let isLocked = target.lockMovementX;

            if (target.type === 'activeSelection' && target._objects && target._objects.length > 0) {
                isLocked = target._objects[0].lockMovementX;
            }
            
            if (isLocked) {
                lockItemText.innerText = "Ëß£ÈîÅ";
                lockIcon.className = "menu-icon-span ri-lock-unlock-line"; 
            } else {
                lockItemText.innerText = "ÈîÅÂÆö";
                lockIcon.className = "menu-icon-span ri-lock-line"; 
            }
        }

        function getCanvasBounds() {
            const winW = window.innerWidth;
            const zoom = canvas.getZoom();
            
            const totalContentW = screenCount * SCREEN_WIDTH * zoom;
            const maxLeft = (winW / 2) - (SCREEN_WIDTH * zoom / 2);
            let minLeft = (winW / 2) - ((screenCount * SCREEN_WIDTH - SCREEN_WIDTH/2) * zoom);
            const sidebarSafeWidth = 80; 
            const minLeftForSidebar = winW - totalContentW - sidebarSafeWidth;
            
            if (minLeftForSidebar < minLeft) {
                minLeft = minLeftForSidebar;
            }

            return { min: minLeft, max: maxLeft };
        }

        function snapBack() {
            const bounds = getCanvasBounds();
            const currentX = canvas.viewportTransform[4];
            let targetX = currentX;

            if (currentX > bounds.max) targetX = bounds.max;
            else if (currentX < bounds.min) targetX = bounds.min;
            else return; 

            fabric.util.animate({
                startValue: currentX,
                endValue: targetX,
                duration: 400,
                easing: fabric.util.ease.easeOutQuart,
                onChange: function(value) {
                    canvas.viewportTransform[4] = value;
                    canvas.requestRenderAll();
                    updateSideBarPosition();
                },
                onComplete: function() {
                      canvas.setViewportTransform(canvas.viewportTransform);
                      updateHitRegions();
                }
            });
        }

        // ==========================================
        // 3. mouse:down (Âä†ÂÖ•ÁßªÂä®Á´ØÂèåÂáªÂà§ÂÆö & ËèúÂçïÂÖ≥Èó≠‰ºòÂåñ)
        // ==========================================
        
        let lastTapTime = 0;
        let lastTapTarget = null;

        canvas.on('mouse:down', function(opt) {
            const evt = opt.e;
            let target = opt.target;
            const now = Date.now();

            // --- [‰ºòÂåñ 2] ÁÇπÂáªÁîªÂ∏É‰ªª‰Ωï‰ΩçÁΩÆ(Â∑¶ÈîÆ)ÔºåÂ¶ÇÊûúÊúâËèúÂçïÊâìÂºÄÔºåÂÖàÂÖ≥Èó≠ ---
            // ÊéíÈô§Âè≥ÈîÆÁÇπÂáª (button 3)ÔºåÂõ†‰∏∫Âè≥ÈîÆË¥üË¥£ÊâìÂºÄËèúÂçï
            if (opt.button !== 3 && contextMenu.style.display === 'block') {
                contextMenu.style.display = 'none';
                document.getElementById('font-options-wrapper').classList.remove('active');
                document.getElementById('filter-options-wrapper').classList.remove('active');
            }

            // --- [Ê†∏ÂøÉ‰øÆÂ§ç] ÁßªÂä®Á´ØÂèåÂáªÊ£ÄÊµãÈÄªËæë ---
            if (evt.type === 'touchstart' && target && target === lastTapTarget && (now - lastTapTime < 300)) {
                // Â¶ÇÊûúÊòØÂõæÁâá -> Èì∫Êª° Toggle
                if (target.type === 'image') {
                    handleImageSmartToggle(target);
                }
                // [V1.17] Â¶ÇÊûúÊòØÊñáÂ≠ó -> ÂºÄÂêØÁºñËæë
                else if ((target.type === 'i-text' || target.type === 'text') && !target.lockMovementX) {
                    target.set('editable', true);
                    target.enterEditing();
                    target.selectAll();
                }

                lastTapTime = 0;
                lastTapTarget = null;
                isDraggingCanvas = false;
                return; 
            }
            lastTapTime = now;
            lastTapTarget = target;
            // ------------------------------------

            const isShiftActive = evt.shiftKey || isVirtualShiftPressed;

            if (isShiftActive) {
                isDraggingCanvas = false; 
                canvas.selection = true; 
                return; 
            }
            
            if (isTextEditingMode) return;

            const pointer = canvas.getPointer(evt); 
            const artboardW = screenCount * SCREEN_WIDTH;
            const artboardH = SCREEN_HEIGHT;
            
            const isOutsideArtboard = pointer.x < 0 || pointer.x > artboardW || pointer.y < 0 || pointer.y > artboardH;
            
            if (isOutsideArtboard) {
                canvas.discardActiveObject();
                canvas._currentTransform = null; 
                canvas.requestRenderAll();
                target = null; 
                opt.target = null;
            }

            cancelAnimationFrame(momentumID);
            velocityX = 0; velocityY = 0;
            lastMoveTime = Date.now();
            
            if (opt.button === 3) {
                if (target && target !== bgRect) {
                    canvas.setActiveObject(target);
                    openContextMenu(opt);
                }
                return;
            }

            const pos = getClientPos(evt);
            lastX = pos.x; lastY = pos.y;
            mouseDownPoint = { x: pos.x, y: pos.y };

            if (!target || target === bgRect) {
                // ËÉåÊôØÁÇπÂáªÔºöÁ°Æ‰øùÂÖ≥Èó≠ÊâÄÊúâËèúÂçï
                contextMenu.style.display = 'none';
                document.getElementById('font-options-wrapper').classList.remove('active');
                document.getElementById('filter-options-wrapper').classList.remove('active');
                
                canvas.selection = false; 
                isDraggingCanvas = true;
                mouseDownTarget = null;
            } else {
                isDraggingCanvas = false;
                
                // [‰ºòÂåñ] ËôΩÁÑ∂ÂâçÈù¢Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÂÖ≥Èó≠ÔºåËøôÈáå‰∏∫‰∫Ü‰øùÈô©Ëµ∑ËßÅÔºåÂ¶ÇÊûúÁ±ªÂûãÂèòÂåñ‰∫Ü‰πüË¶ÅÊõ¥Êñ∞Áä∂ÊÄÅ
                const currentType = getBroadType(target.type);
                const menuType = contextMenu.dataset.currentType; 
                if (currentType !== menuType && contextMenu.style.display === 'block') {
                    contextMenu.style.display = 'none';
                }
                
                if (target.lockMovementX) {
                    if (!target.__corner) {
                         isDraggingCanvas = true;
                         mouseDownTarget = target; 
                    }
                    canvas.requestRenderAll();
                }
            }
            
            if (bgPanel.style.display === 'block') bgPanel.style.display = 'none';
            
            if (target && target !== bgRect && evt.type === 'touchstart') {
                // --- [‰ºòÂåñ 1] Â¶ÇÊûúÂ∑≤ÁªèÊòØÂèåÊåáÊé•Ëß¶Ôºå‰∏çËß¶ÂèëÈïøÊåâËèúÂçï ---
                if (evt.touches && evt.touches.length > 1) return;

                if (target.__corner) return;
                longPressTimer = setTimeout(() => {
                    const active = canvas.getActiveObject();
                    
                    if ((target.type === 'i-text' || target.type === 'text')) {
                        // ÈïøÊåâÊó∂‰æùÁÑ∂Á¶ÅÊ≠¢ÁºñËæë
                        target.set('editable', false);
                        target.__tempDisableEdit = true;
                    }

                    if (isDraggingCanvas && Math.abs(lastX - pos.x) < 5 && Math.abs(lastY - pos.y) < 5) {
                        isDraggingCanvas = false; 
                        canvas.setActiveObject(target); 
                        openContextMenu(opt);
                    } else if (!isDraggingCanvas && active && !active.isMoving && !active.isScaling && !active.isRotating) {
                        openContextMenu(opt);
                    }
                }, 500);
            }
        });

        let isObjectMoving = false;
        canvas.on('mouse:move', function(opt) {
            if (isTextEditingMode) return;

            if (isDraggingCanvas) {
                const evt = opt.e;
                const pos = getClientPos(evt);
                if (pos.x === undefined || pos.y === undefined) return;
                
                const now = Date.now();
                const dt = now - lastMoveTime;

                let deltaX = pos.x - lastX;
                let deltaY = pos.y - lastY;

                if (dt > 0) {
                    const newVx = deltaX / dt;
                    const newVy = deltaY / dt;
                    velocityX = velocityX * 0.5 + newVx * 0.5;
                    velocityY = velocityY * 0.5 + newVy * 0.5;
                    lastMoveTime = now;
                }

                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    clearTimeout(longPressTimer);
                }

                if (layoutState.visualHeight <= layoutState.availableHeight) {
                    deltaY = 0; 
                    velocityY = 0; 
                }

                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                const proposedX = currentX + deltaX;

                if (proposedX > bounds.max) {
                      const overage = proposedX - bounds.max;
                      const resistance = 1 / (1 + Math.abs(overage) * 0.003); 
                      deltaX *= resistance;
                } else if (proposedX < bounds.min) {
                      const overage = bounds.min - proposedX;
                      const resistance = 1 / (1 + Math.abs(overage) * 0.003);
                      deltaX *= resistance;
                }

                canvas.relativePan({ x: deltaX, y: deltaY });
                updateSideBarPosition();
                
                lastX = pos.x;
                lastY = pos.y;
            } else {
                const active = canvas.getActiveObject();
                if (active && (active.isMoving || active.isScaling || active.isRotating)) {
                    isObjectMoving = true;
                    clearTimeout(longPressTimer);
                }
            }
        });

        canvas.on('mouse:up', function(opt) {
            canvas.selection = true;

            const evt = opt.e;
            const pos = getClientPos(evt);
            
            if (isDraggingCanvas && mouseDownTarget && mouseDownTarget.lockMovementX) {
                const dist = Math.sqrt(Math.pow(pos.x - mouseDownPoint.x, 2) + Math.pow(pos.y - mouseDownPoint.y, 2));
                if (dist < 5) { 
                    canvas.setActiveObject(mouseDownTarget);
                    canvas.requestRenderAll();
                }
            }

            if (isDraggingCanvas) {
                const timeSinceLastMove = Date.now() - lastMoveTime;
                if (timeSinceLastMove > 100) {
                    velocityX = 0;
                    velocityY = 0;
                }
                
                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                
                if (currentX > bounds.max || currentX < bounds.min) {
                    velocityX = 0; velocityY = 0;
                    snapBack();
                } else {
                    applyMomentum();
                }
            }

            isDraggingCanvas = false;
            isObjectMoving = false;
            clearTimeout(longPressTimer);
            canvas.setViewportTransform(canvas.viewportTransform); 
            updateSideBarPosition();
            updateHitRegions(); 

            if (opt.target && opt.target.__tempDisableEdit) {
                 if (!opt.target.lockMovementX) {
                      // ËøôÈáå‰∏çÂÅö‰ªª‰ΩïÊìç‰ΩúÔºåÂõ†‰∏∫Êàë‰ª¨‰∏çÊÉ≥ÂçïÂáªËøõÂÖ•ÁºñËæë
                 }
                 delete opt.target.__tempDisableEdit;
            }
        });

        function applyMomentum() {
            const friction = 0.95; 
            const stopThreshold = 0.01;

            function step() {
                if (Math.abs(velocityX) < stopThreshold && Math.abs(velocityY) < stopThreshold) {
                    cancelAnimationFrame(momentumID);
                    return;
                }

                velocityX *= friction;
                velocityY *= friction;

                let panX = velocityX * 16; 
                let panY = velocityY * 16;

                if (layoutState.visualHeight <= layoutState.availableHeight) {
                    panY = 0;
                }

                const bounds = getCanvasBounds();
                const currentX = canvas.viewportTransform[4];
                const proposedX = currentX + panX;

                if (proposedX > bounds.max || proposedX < bounds.min) {
                    cancelAnimationFrame(momentumID);
                    snapBack();
                    return;
                }

                canvas.relativePan({ x: panX, y: panY });
                updateSideBarPosition();
                
                momentumID = requestAnimationFrame(step);
            }
            step();
        }

        canvas.on('mouse:wheel', function(opt) {
            opt.e.preventDefault();
            opt.e.stopPropagation();
        });

        let initialDistance = 0;
        let initialZoom = 1;
        let initialObjectScale = 1;
        let activeObjectForPinch = null;
        let pinchMode = null; 

        canvas.upperCanvasEl.addEventListener('touchstart', function(e) {
            if (e.touches.length === 2) {
                // --- [‰ºòÂåñ 1] ÂèåÊåáÊìç‰ΩúÁ´ãÂç≥ÂèñÊ∂àÈïøÊåâÂÆöÊó∂Âô® ---
                clearTimeout(longPressTimer);
                
                isDraggingCanvas = false; 
                const pointer0 = canvas.getPointer(e.touches[0]); 
                let target = canvas.findTarget(e); 
                if (target === bgRect) target = null;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                initialDistance = Math.sqrt(dx * dx + dy * dy);
                if (target && target === canvas.getActiveObject()) {
                    pinchMode = 'object';
                    initialObjectScale = target.scaleX;
                } else {
                    pinchMode = null; 
                }
                e.preventDefault();
            }
        }, { passive: false });

        canvas.upperCanvasEl.addEventListener('touchmove', function(e) {
            if (e.touches.length === 2 && initialDistance > 0) {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const currentDistance = Math.sqrt(dx * dx + dy * dy);
                
                if (pinchMode === 'object') {
                    const target = canvas.getActiveObject();
                    if(target) {
                        const scaleFactor = currentDistance / initialDistance;
                        let newScale = initialObjectScale * scaleFactor;
                        if(newScale < 0.1) newScale = 0.1;
                        target.scale(newScale);
                        target.setCoords();
                        canvas.requestRenderAll();
                    }
                }
            }
        }, { passive: false });
        
        canvas.upperCanvasEl.addEventListener('touchend', function(e) {
            if(e.touches.length < 2) {
                initialDistance = 0;
                pinchMode = null;
                updateHitRegions(); 
            }
        });

        let longPressTimer;
        const FONT_WEIGHTS = [100, 200, 300, 400, 500, 600, 700, 800, 900];

        function menuAction(action) {
            const obj = canvas.getActiveObject(); if (!obj) return;
            switch(action) {
                case 'lock-toggle':
                      toggleLockHandler(null, {target: obj});
                      break;

                case 'top': obj.bringToFront(); break; case 'bottom': obj.sendToBack(); break;
                case 'up': obj.bringForward(); break; case 'down': obj.sendBackwards(); break;
                
                case 'delete': 
                    if (obj.type === 'activeSelection') {
                        obj.forEachObject(subObj => canvas.remove(subObj));
                        canvas.discardActiveObject();
                    } else {
                        canvas.remove(obj); 
                        canvas.discardActiveObject(); 
                    }
                    break;

                case 'duplicate':
                    obj.clone(function(cloned) {
                        canvas.discardActiveObject();
                        cloned.set({ left: obj.left + 20, top: obj.top + 20, evented: true });
                        if(cloned.type === 'i-text' || cloned.type === 'text') {
                            cloned.set('objectCaching', false);
                            // [V1.17] Â§çÂà∂Êó∂‰πü‰øùÊåÅ‰∏çÂèØÁºñËæë
                            cloned.set('editable', false);
                        }
                        if (cloned.type === 'activeSelection') {
                            cloned.canvas = canvas;
                            cloned.forEachObject(function(o) { canvas.add(o); });
                            cloned.setCoords();
                        } else { canvas.add(cloned); }
                        canvas.setActiveObject(cloned);
                        canvas.requestRenderAll();
                        triggerAutoSave();
                    });
                    break;
                case 'flipX': if(obj.type === 'image') obj.set('flipX', !obj.flipX); break;
                case 'shadow': if (obj.type === 'image') { if (obj.shadow) { obj.set('shadow', null); } else { obj.set('shadow', new fabric.Shadow({ color: 'rgba(0,0,0,0.5)', blur: 20, offsetX: 10, offsetY: 10 })); } } break;
                case 'spacing-up': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.charSpacing || 0; obj.set('charSpacing', val + 50); } break;
                case 'spacing-down': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.charSpacing || 0; obj.set('charSpacing', val - 50); } break;
                case 'line-height-up': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.lineHeight || 1.16; obj.set('lineHeight', val + 0.1); } break;
                case 'line-height-down': if (obj.type === 'i-text' || obj.type === 'text') { let val = obj.lineHeight || 1.16; if(val > 0.5) obj.set('lineHeight', val - 0.1); } break;
                case 'align-left': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'left'); break;
                case 'align-center': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'center'); break;
                case 'align-right': if (obj.type === 'i-text' || obj.type === 'text') obj.set('textAlign', 'right'); break;
                case 'weight-up': if (obj.type === 'i-text' || obj.type === 'text') { let current = parseInt(obj.fontWeight) || 600; if(current === 'normal') current = 400; if(current === 'bold') current = 700; let next = FONT_WEIGHTS.find(w => w > current); if (!next) next = FONT_WEIGHTS[FONT_WEIGHTS.length - 1]; obj.set('fontWeight', next); } break;
                case 'weight-down': if (obj.type === 'i-text' || obj.type === 'text') { let current = parseInt(obj.fontWeight) || 600; if(current === 'normal') current = 400; if(current === 'bold') current = 700; let prev = [...FONT_WEIGHTS].reverse().find(w => w < current); if (!prev) prev = FONT_WEIGHTS[0]; obj.set('fontWeight', prev); } break;
            }
            if(bgRect) canvas.sendToBack(bgRect);
            bringGridToFront(); canvas.renderAll(); triggerAutoSave();
            
            const keepOpen = [
                'weight-up', 'weight-down', 
                'spacing-up', 'spacing-down', 
                'line-height-up', 'line-height-down', 
                'align-left', 'align-center', 'align-right',
                'top', 'bottom', 'up', 'down',
                'lock-toggle' 
            ];
            
            if (!keepOpen.includes(action)) {
                contextMenu.style.display = 'none';
                document.getElementById('font-options-wrapper').classList.remove('active');
                document.getElementById('font-arrow-icon').className = "ri-arrow-right-s-line";
                document.getElementById('filter-options-wrapper').classList.remove('active');
                if(document.getElementById('filter-arrow-icon')) document.getElementById('filter-arrow-icon').className = "ri-arrow-right-s-line";
            }
        }

        function openContextMenu(opt) {
            const target = opt.target || canvas.getActiveObject();
            if(!target || target === bgRect) return;
            
            canvas.setActiveObject(target);
            const type = target.type;
            const imageItems = document.querySelectorAll('.image-menu-item');
            const textItems = document.querySelectorAll('.text-menu-item');
            const layerControls = document.querySelector('.layer-controls'); 

            if (type === 'activeSelection') {
                layerControls.style.display = 'none';
            } else {
                layerControls.style.display = 'flex';
            }

            contextMenu.dataset.currentType = getBroadType(type);
            updateContextMenuState(target);

            document.getElementById('font-options-wrapper').classList.remove('active');
            document.getElementById('font-arrow-icon').className = "ri-arrow-right-s-line";
            document.getElementById('filter-options-wrapper').classList.remove('active');
            if(document.getElementById('filter-arrow-icon')) document.getElementById('filter-arrow-icon').className = "ri-arrow-right-s-line";

            if (type === 'image') {
                imageItems.forEach(el => el.style.display = 'flex');
                textItems.forEach(el => el.style.display = 'none');
            } else if (type === 'i-text' || type === 'text') {
                imageItems.forEach(el => el.style.display = 'none');
                textItems.forEach(el => el.style.display = 'flex'); 
            } else {
                imageItems.forEach(el => el.style.display = 'none');
                textItems.forEach(el => el.style.display = 'none');
            }

            let clientX, clientY;
            if (opt.e.changedTouches && opt.e.changedTouches[0]) {
                clientX = opt.e.changedTouches[0].clientX;
                clientY = opt.e.changedTouches[0].clientY;
            } else {
                clientX = opt.e.clientX;
                clientY = opt.e.clientY;
            }

            contextMenu.style.display = 'block';
            const menuW = contextMenu.offsetWidth;
            const menuH = contextMenu.offsetHeight;

            let left = clientX + 10;
            let top = clientY - (menuH / 2);

            if (left + menuW > window.innerWidth) left = clientX - menuW - 10;
            if (top + menuH > window.innerHeight) top = window.innerHeight - menuH - 10;
            if (top < 10) top = 10;

            contextMenu.style.left = left + 'px';
            contextMenu.style.top = top + 'px';
            bgPanel.style.display = 'none';
        }

        function toggleFontList() {
            const list = document.getElementById('font-options-wrapper');
            const arrow = document.getElementById('font-arrow-icon');
            list.classList.toggle('active');
            document.getElementById('filter-options-wrapper').classList.remove('active');
            
            if(list.classList.contains('active')) {
                arrow.className = "ri-arrow-left-s-line";
            } else {
                arrow.className = "ri-arrow-right-s-line";
            }
        }

        function toggleFilterList() {
            const list = document.getElementById('filter-options-wrapper');
            const arrow = document.getElementById('filter-arrow-icon');
            list.classList.toggle('active');
            document.getElementById('font-options-wrapper').classList.remove('active');

            if(list.classList.contains('active')) {
                arrow.className = "ri-arrow-left-s-line";
            } else {
                arrow.className = "ri-arrow-right-s-line";
            }
        }
        
        function applyFilter(type) {
            const activeObj = canvas.getActiveObject();
            if (!activeObj || activeObj.type !== 'image') return;

            activeObj.filters = []; 

            switch (type) {
                case 'bw':
                    activeObj.filters.push(new fabric.Image.filters.Grayscale());
                    break;
                case 'cyber':
                    activeObj.filters.push(new fabric.Image.filters.Composed({
                        subFilters: [
                            new fabric.Image.filters.Grayscale({ mode: 'luminosity' }),
                            new fabric.Image.filters.BlendColor({ color: '#76ff03', mode: 'multiply' }),
                            new fabric.Image.filters.BlendColor({ color: '#2962ff', mode: 'lighten' })
                        ]
                    }));
                    break;
                case 'sunset':
                    activeObj.filters.push(new fabric.Image.filters.Composed({
                        subFilters: [
                            new fabric.Image.filters.Grayscale({ mode: 'luminosity' }),
                            new fabric.Image.filters.BlendColor({ color: '#ffd600', mode: 'multiply' }),
                            new fabric.Image.filters.BlendColor({ color: '#d50000', mode: 'lighten' })
                        ]
                    }));
                    break;
                case 'violet':
                    activeObj.filters.push(new fabric.Image.filters.Composed({
                        subFilters: [
                            new fabric.Image.filters.Grayscale({ mode: 'luminosity' }),
                            new fabric.Image.filters.BlendColor({ color: '#e040fb', mode: 'multiply' }),
                            new fabric.Image.filters.BlendColor({ color: '#4a148c', mode: 'lighten' })
                        ]
                    }));
                    break;
                case 'none':
                    break;
            }

            activeObj.applyFilters();
            canvas.requestRenderAll();
            triggerAutoSave();
            toggleFilterList(); 
        }

        function addDefaultText() {
            const center = canvas.getVpCenter();

            const title = new fabric.IText('SparkCanvas', {
                left: SCREEN_WIDTH / 2, 
                top: SCREEN_HEIGHT / 2 - 12,
                fontFamily: "'Outfit', sans-serif", 
                fontWeight: 600, 
                fill: '#000000', 
                fontSize: 40,
                originX: 'center', 
                originY: 'center',
                textAlign: 'center',
                charSpacing: 0,
                shadow: null,
                objectCaching: false,
                editable: false // [V1.17] ÈªòËÆ§‰∏çÂèØÁºñËæë
            });
            title.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });

            const subText = new fabric.IText('Âè≥ÈîÆÊàñÈïøÊåâ Âî§Âá∫ËèúÂçï', {
                left: SCREEN_WIDTH / 2,
                top: SCREEN_HEIGHT / 2 + 28, 
                fontFamily: "'Noto Sans SC', sans-serif", 
                fontWeight: 400, 
                fill: '#999999', 
                fontSize: 12,
                originX: 'center', 
                originY: 'center',
                textAlign: 'center',
                objectCaching: false,
                editable: false // [V1.17] ÈªòËÆ§‰∏çÂèØÁºñËæë
            });
            subText.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false, bl: false, br: false, tl: false, tr: false, mtr: false });

            canvas.add(title);
            canvas.add(subText);
            canvas.requestRenderAll();
        }

        function resizeImage(dataUrl, callback) {
            const img = new Image();
            img.onload = () => {
                const maxDim = 2048; 
                let width = img.width;
                let height = img.height;

                if (width > maxDim || height > maxDim) {
                    if (width > height) {
                        height *= maxDim / width;
                        width = maxDim;
                    } else {
                        width *= maxDim / height;
                        height = maxDim;
                    }
                    
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = width;
                    tempCanvas.height = height;
                    const ctx = tempCanvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    callback(tempCanvas.toDataURL('image/jpeg', 0.9)); 
                } else {
                    callback(dataUrl);
                }
            };
            img.src = dataUrl;
        }

        function showModal() { confirmModal.style.display = 'block'; }
        function closeModal() { confirmModal.style.display = 'none'; }
        
        function showInfoModal() { infoModal.style.display = 'block'; }
        function closeInfoModal() { infoModal.style.display = 'none'; }

        function executeClear() {
            // 1. Ê∏ÖÁ©∫ÂØπË±°Ôºå‰ΩÜ‰∏çÈáçÁΩÆ screenHeight
            canvas.clear(); 
            bgRect = null;
            gridLines = [];
            screenCount = 1; 
            currentBgFill = '#ffffff'; 
            
            document.getElementById('color-picker-btn').style.backgroundColor = '#ffffff';
            
            updateWorkspace();
            addDefaultText(); 
            initViewport();
            
            // 2. ÂÖ≥ÈîÆ‰øÆÊîπÔºö‰∏çÂÜçÂà†Èô§ DB ËÆ∞ÂΩïÔºåËÄåÊòØ‰øùÂ≠òÂΩìÂâçÔºàÁ©∫ÔºâÁä∂ÊÄÅ
            // ËøôÊ†∑ÂΩìÂâçÁöÑ SCREEN_HEIGHT ‰ºöË¢´ÊåÅ‰πÖÂåñ‰øùÂ≠ò
            saveState(); 
            
            closeModal();
        }

        function changeFont(fontFamily) {
            const activeObj = canvas.getActiveObject();
            if (activeObj && (activeObj.type === 'i-text' || activeObj.type === 'text')) {
                activeObj.set("fontFamily", fontFamily);
                activeObj.set("fontWeight", 600);
                canvas.requestRenderAll();
                triggerAutoSave();
                toggleFontList();
            }
        }

        function changeTextColor(color) {
            const activeObj = canvas.getActiveObject();
            if (activeObj && (activeObj.type === 'i-text' || activeObj.type === 'text')) {
                activeObj.set("fill", color);
                canvas.requestRenderAll();
                triggerAutoSave();
            }
        }

        function addText() {
            const center = canvas.getVpCenter();
            const selectedFont = "'Outfit', sans-serif";
            const text = new fabric.IText('SparkCanvas', {
                left: center.x, top: center.y,
                fontFamily: selectedFont, 
                fontWeight: 600, 
                fill: '#000000', 
                fontSize: 40,
                originX: 'center', 
                originY: 'center',
                textAlign: 'left',
                charSpacing: 0,
                shadow: null,
                objectCaching: false,
                editable: false // [V1.17] ÈªòËÆ§‰∏çÂèØÁºñËæë
            });
            text.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
            canvas.add(text);
            canvas.setActiveObject(text);
            triggerAutoSave();
        }

        function addScreen() { 
            screenCount++; 
            updateWorkspace(); 
            canvas.requestRenderAll(); 
            triggerAutoSave(); 
            focusOnPage(screenCount - 1);
        }
        function removeScreen() { 
            if (screenCount > 1) { 
                screenCount--; 
                updateWorkspace(); 
                canvas.requestRenderAll(); 
                triggerAutoSave(); 
                focusOnPage(screenCount - 1);
            } 
        }

        function toggleBgPanel() {
            const isVisible = bgPanel.style.display === 'block';
            bgPanel.style.display = isVisible ? 'none' : 'block';
        }

        function changeBackgroundColor(color) {
            currentBgFill = color;
            document.getElementById('color-picker-btn').style.backgroundColor = color; 
            if(bgRect) {
                bgRect.set('fill', color);
                canvas.requestRenderAll();
                triggerAutoSave();
            }
        }

        function handleFiles(files) {
            if (!files || !files[0]) return;
            Array.from(files).forEach(file => processImageFile(file, false));
            document.getElementById('file-input').value = '';
        }

        function handleBgFile(files) {
            if (!files || !files[0]) return;
            processImageFile(files[0], true);
            document.getElementById('bg-file-input').value = '';
        }

        function applyPattern(imgSrc) {
            fabric.util.loadImage(imgSrc, function(img) {
                if(!img) return;
                const pattern = new fabric.Pattern({ source: img, repeat: 'repeat' });
                currentBgFill = pattern;
                if(bgRect) {
                    bgRect.set('fill', pattern);
                    canvas.requestRenderAll();
                    triggerAutoSave();
                }
            });
        }

        function processImageFile(file, isBackground = false) {
            const reader = new FileReader();
            reader.onload = (f) => {
                resizeImage(f.target.result, (resizedDataUrl) => {
                    if (isBackground) {
                        applyPattern(resizedDataUrl);
                    } else {
                        const center = canvas.getVpCenter();
                        fabric.Image.fromURL(resizedDataUrl, (img) => {
                            if (img.width > SCREEN_WIDTH) img.scaleToWidth(SCREEN_WIDTH * 0.8);
                            const offsetX = (Math.random() * 40 - 20);
                            const offsetY = (Math.random() * 40 - 20);
                            img.set({ left: center.x - (img.getScaledWidth()/2) + offsetX, top: center.y - (img.getScaledHeight()/2) + offsetY });
                            img.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                            canvas.add(img); 
                            canvas.setActiveObject(img); 
                            bringGridToFront(); 
                            triggerAutoSave();
                            canvas.requestRenderAll(); 
                        });
                    }
                });
            };
            reader.readAsDataURL(file);
        }

        let renderingLines = [];

        canvas.on('object:moving', function(e) {
            const obj = e.target;
            const threshold = 15; 
            renderingLines = []; 
            
            const objCenter = obj.getCenterPoint();
            let finalX = objCenter.x;
            let finalY = objCenter.y;
            
            const pageIndex = Math.floor((obj.left + obj.width * obj.scaleX / 2) / SCREEN_WIDTH);
            const screenCenterX = pageIndex * SCREEN_WIDTH + SCREEN_WIDTH / 2;
            const screenCenterY = SCREEN_HEIGHT / 2; 

            let snappedX = false, snappedY = false;

            if (Math.abs(objCenter.x - screenCenterX) < threshold) {
                finalX = screenCenterX;
                renderingLines.push({x1: screenCenterX, y1: 0, x2: screenCenterX, y2: SCREEN_HEIGHT});
                snappedX = true;
            }
            if (Math.abs(objCenter.y - screenCenterY) < threshold) {
                finalY = screenCenterY;
                renderingLines.push({x1: pageIndex * SCREEN_WIDTH, y1: screenCenterY, x2: (pageIndex + 1) * SCREEN_WIDTH, y2: screenCenterY});
                snappedY = true;
            }

            if (!snappedX || !snappedY) {
                canvas.getObjects().forEach(target => {
                    if (target === obj || target === bgRect || target.excludeFromExport || !target.visible) return;
                    const tCenter = target.getCenterPoint();
                    if (!snappedX && Math.abs(objCenter.x - tCenter.x) < threshold) {
                        finalX = tCenter.x;
                        renderingLines.push({
                            x1: tCenter.x, 
                            y1: Math.min(obj.top, target.top)-50, 
                            x2: tCenter.x, 
                            y2: Math.max(obj.top+obj.height*obj.scaleY, target.top+target.height*target.scaleY)+50
                        });
                        snappedX = true;
                    }
                    if (!snappedY && Math.abs(objCenter.y - tCenter.y) < threshold) {
                        finalY = tCenter.y;
                        renderingLines.push({
                            x1: Math.min(obj.left, target.left)-50, 
                            y1: tCenter.y, 
                            x2: Math.max(obj.left+obj.width*obj.scaleX, target.left+target.width*target.scaleX)+50, 
                            y2: tCenter.y
                        });
                        snappedY = true;
                    }
                });
            }
            obj.setPositionByOrigin(new fabric.Point(finalX, finalY), 'center', 'center');
            canvas.requestRenderAll();
        });
        
        canvas.on('mouse:up', function() { 
            renderingLines = []; 
            canvas.requestRenderAll(); 
        });

        canvas.on('after:render', function(opt) {
            if(renderingLines.length === 0) return;
            const ctx = canvas.getContext();
            ctx.save();
            const vpt = canvas.viewportTransform;
            const retina = canvas.getRetinaScaling();
            ctx.setTransform(vpt[0] * retina, vpt[1] * retina, vpt[2] * retina, vpt[3] * retina, vpt[4] * retina, vpt[5] * retina);
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#5213dc';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            renderingLines.forEach(l => { ctx.moveTo(l.x1, l.y1); ctx.lineTo(l.x2, l.y2); });
            ctx.stroke();
            ctx.restore();
        });

        function initDB() {
            try {
                const request = indexedDB.open(DB_NAME, 1);
                request.onupgradeneeded = (e) => { db = e.target.result; if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME); };
                request.onsuccess = (e) => { db = e.target.result; loadState(); };
            } catch(e) { console.log("DB Error", e); }
        }

        function saveState() {
            if (!db || isInternalUpdate) return;
            canvas.clipPath = null;
            const json = canvas.toJSON(['isBackground', 'lockMovementX', 'lockMovementY', 'lockRotation', 'lockScalingX', 'lockScalingY', 'hasControls', 'borderColor']);
            updateWorkspace(); 
            const saveData = { id: "autosave", canvas: json, screenCount: screenCount, bgFill: currentBgFill, screenHeight: SCREEN_HEIGHT, updated: new Date().getTime() };
            const tx = db.transaction(STORE_NAME, "readwrite");
            tx.objectStore(STORE_NAME).put(saveData, "last_session");
        }

        function loadState() {
            const tx = db.transaction(STORE_NAME, "readonly");
            tx.objectStore(STORE_NAME).get("last_session").onsuccess = (e) => {
                const data = e.target.result;
                if (data) {
                    screenCount = data.screenCount || 1;
                    if (data.screenHeight) {
                        SCREEN_HEIGHT = data.screenHeight;
                        // V1.09 Update: Âä®ÊÄÅËÆæÁΩÆÂä†ËΩΩÂêéÁöÑÊåâÈíÆÊñáÂ≠ó (ÊòæÁ§∫‰∏ã‰∏Ä‰∏™Áä∂ÊÄÅ)
                        let label = "1:1"; // Default next for 9:16
                        if (Math.abs(SCREEN_HEIGHT - 960) < 5) label = "1:1"; 
                        else if (Math.abs(SCREEN_HEIGHT - 540) < 5) label = "3:4"; 
                        else if (Math.abs(SCREEN_HEIGHT - 720) < 5) label = "9:16"; 
                        ratioToggleBtn.innerText = label;
                    }
                    if (data.bgFill) {
                        currentBgFill = data.bgFill;
                        if (typeof currentBgFill === 'string') {
                            document.getElementById('color-picker-btn').style.backgroundColor = currentBgFill;
                            document.getElementById('bg-picker').value = currentBgFill;
                        }
                    }

                    canvas.loadFromJSON(data.canvas, () => {
                        const objectsToRemove = [];
                        canvas.getObjects().forEach(obj => {
                            if (obj.isBackground || (obj.type === 'rect' && obj.width >= SCREEN_WIDTH && obj.top === 0 && obj.left === 0)) {
                                if(!data.bgFill) currentBgFill = obj.fill; 
                                objectsToRemove.push(obj); 
                            }
                        });
                        objectsToRemove.forEach(obj => canvas.remove(obj));
                        updateWorkspace(); 
                        
                        let hasContent = false;
                        canvas.getObjects().forEach(obj => { 
                            if(obj === bgRect) return;
                            if (obj.type === 'image' || obj.type === 'i-text' || obj.type === 'text') {
                                hasContent = true;
                            }
                            
                            if(obj.type === 'image') {
                                obj.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                                obj.set('noScaleCache', false); 
                            } else if (obj.type === 'i-text' || obj.type === 'text') {
                                obj.setControlsVisibility({ mt: false, mb: false, ml: false, mr: false });
                                obj.set('shadow', null);
                                obj.set('objectCaching', false);
                                // [V1.17] ËΩΩÂÖ•Êó∂Âº∫Âà∂‰∏çÂèØÁºñËæëÔºåÈò≤Ê≠¢ÊóßÊï∞ÊçÆÂπ≤Êâ∞
                                obj.set('editable', false);
                            }
                            if (obj.lockMovementX) {
                                updateVisualState(obj, true);
                            } else {
                                updateVisualState(obj, false);
                            }
                        });

                        if (!hasContent) {
                            addDefaultText();
                        }

                        drawGrid(); 
                        initViewport(); 
                        hideSplashScreen(); 
                    });
                } else { 
                    // Á¨¨‰∏ÄÊ¨°Âä†ËΩΩÔºàÊàñÊï∞ÊçÆ‰∏¢Â§±ÔºâÔºåÂº∫Âà∂ 9:16ÔºåÊåâÈíÆÊòæÁ§∫ "1:1"
                    SCREEN_HEIGHT = 960;
                    ratioToggleBtn.innerText = "1:1";
                    
                    updateWorkspace(); 
                    drawGrid(); 
                    addDefaultText();
                    initViewport();
                    hideSplashScreen(); 
                }
            };
        }

        function triggerAutoSave() {
            if(isInternalUpdate) return;
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveState, 1000);
        }

        canvas.on('object:modified', triggerAutoSave); canvas.on('object:added', triggerAutoSave); canvas.on('object:removed', triggerAutoSave);
        
        function drawGrid() {
            gridLines.forEach(l => canvas.remove(l)); 
            gridLines = [];
            for (let i = 1; i < screenCount; i++) {
                const line = new fabric.Line([i * SCREEN_WIDTH, 0, i * SCREEN_WIDTH, SCREEN_HEIGHT], {
                    stroke: '#5213dc', strokeWidth: 1, strokeDashArray: [5, 5], opacity: 0.3, selectable: false, evented: false, excludeFromExport: true
                });
                canvas.add(line); gridLines.push(line);
            }
            bringGridToFront();
        }
        function bringGridToFront() { gridLines.forEach(l => l.bringToFront()); }

        async function exportContent() {
            statusIndicator.innerText = "ÂáÜÂ§áÂØºÂá∫..."; 
            
            const originalVpt = canvas.viewportTransform.slice();
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;
            canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
            canvas.setWidth(screenCount * SCREEN_WIDTH);
            canvas.setHeight(SCREEN_HEIGHT); 
            gridLines.forEach(l => l.visible = false);
            canvas.clipPath = null; canvas.renderAll();

            const blobs = [];
            for (let i = 0; i < screenCount; i++) {
                const dataURL = canvas.toDataURL({ format: 'png', quality: 1, multiplier: 2, left: i * SCREEN_WIDTH, top: 0, width: SCREEN_WIDTH, height: SCREEN_HEIGHT });
                const blob = await (await fetch(dataURL)).blob();
                blobs.push(blob);
            }

            let shareSuccess = false;
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            
            try {
                if (isMobile && navigator.share && navigator.canShare) {
                    const files = blobs.map((blob, i) => new File([blob], `spark_slice_${i+1}.png`, { type: 'image/png' }));
                    if (navigator.canShare({ files })) {
                        statusIndicator.innerText = "Ë∞ÉËµ∑ÂàÜ‰∫´...";
                        await navigator.share({ files: files, title: 'Spark Canvas', text: 'Áî± Spark Canvas ÁîüÊàê' });
                        shareSuccess = true;
                        statusIndicator.innerText = "Â∑≤ÂÆåÊàê"; 
                    }
                }
            } catch (err) { console.log("Share skipped/cancelled", err); }

            if (!shareSuccess) {
                statusIndicator.innerText = "ÂºÄÂßã‰∏ãËΩΩ...";
                for (let i = 0; i < blobs.length; i++) {
                    statusIndicator.innerText = `‰∏ãËΩΩ‰∏≠ ${i+1}/${blobs.length}`;
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blobs[i]); a.download = `spark_slice_${i + 1}.png`;
                    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                    if (i < blobs.length - 1) await new Promise(r => setTimeout(r, 1500));
                }
                statusIndicator.innerText = "‰∏ãËΩΩÂÆåÊàê"; 
            }
            
            canvas.setViewportTransform(originalVpt); canvas.setWidth(originalWidth); canvas.setHeight(originalHeight);
            gridLines.forEach(l => l.visible = true); updateWorkspace(); canvas.requestRenderAll();
        }
        
        initDB();
    </script>
</body>
</html>
